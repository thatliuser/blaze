mod ZumChqTorR { use crate :: RwhTHuZJWW :: ZmBnAjyBPT ; use crate :: XnwjfBIAxG :: nygzfkJpcK :: CrchwJMsNc ; use anyhow :: Context ; use cidr :: IpCidr as sdzYnHghPx ; use serde :: { Deserialize , Serialize } ; use std :: io :: { BufRead , Write } ; use std :: net :: Ipv4Addr ; use std :: time :: Duration as reMfYVqQaG ; use std :: { collections :: { HashMap as yNSnqqaRKD , HashSet } , fs :: File as VZlCLjqPDi , io :: BufReader as HCSHEAATJN , io :: BufWriter as wCyuyMHIae , net :: IpAddr as nrRdtqRmYR , path :: { Path , PathBuf } , } ; # [derive (Debug , Clone , Serialize , Deserialize)] pub struct IGGqPVcktO { pub ehmAIyyTsT : nrRdtqRmYR , pub EUIBybvxzR : String , pub RCEWxSXxDu : Option < String > , pub XfiOfpdLRW : u16 , pub AtxPWiUcZC : HashSet < u16 > , pub VCeqAEcxUW : HashSet < String > , pub WpFxLZmBnAjyBPT : ZmBnAjyBPT , pub aAoAoHiCrb : HashSet < String > , } impl IGGqPVcktO { pub fn qoXfhfLQZV (& self) -> String { self . VCeqAEcxUW . iter () . next () . cloned () . unwrap_or_else (| | self . ehmAIyyTsT . to_string ()) } } impl std :: fmt :: Display for IGGqPVcktO { fn fmt (& self , hbNSiaHfZv : & mut std :: fmt :: Formatter < '_ >) -> std :: fmt :: Result { hbNSiaHfZv . write_str (& self . qoXfhfLQZV ()) } } # [derive (Serialize , Deserialize)] struct sElCDVdLmF { pub HufwaNcdTR : yNSnqqaRKD < nrRdtqRmYR , IGGqPVcktO > , pub iGUOybgENv : Option < sdzYnHghPx > , pub vizispDrXX : reMfYVqQaG , pub mEgnvlxemV : reMfYVqQaG , pub ozBRVtyRBJ : Vec < u8 > , pub YnfwmzWLem : String , pub pcfxYEXSfZ : String , } impl sElCDVdLmF { pub fn EnrDxOQKLP () -> Self { Self { HufwaNcdTR : yNSnqqaRKD :: new () , iGUOybgENv : None , vizispDrXX : reMfYVqQaG :: from_secs (15) , mEgnvlxemV : reMfYVqQaG :: from_millis (150) , ozBRVtyRBJ : vec ! [1 , 2] , YnfwmzWLem : "root" . into () , pcfxYEXSfZ : "Administrator" . into () , } } } pub struct SAuuizgQav { ozIUomtdwG : sElCDVdLmF , wvqMVtvyCm : PathBuf , } impl SAuuizgQav { pub fn QJzJMmAYQK () -> SAuuizgQav { SAuuizgQav { ozIUomtdwG : sElCDVdLmF :: EnrDxOQKLP () , wvqMVtvyCm : PathBuf :: from ("blaze.yaml") , } } pub fn CtFTwTYgKa (& mut self , JkgLUzJiqJ : sdzYnHghPx) { self . ozIUomtdwG . iGUOybgENv = Some (JkgLUzJiqJ) ; } pub fn sElCDVdLmF (& self) -> Option < sdzYnHghPx > { self . ozIUomtdwG . iGUOybgENv } pub fn hLjrDRRznd (jNwYXtrnkx : & PathBuf) -> anyhow :: Result < SAuuizgQav > { let ZYlwrJjCoY = VZlCLjqPDi :: open (jNwYXtrnkx) ? ; let pThWtFoBFK = HCSHEAATJN :: new (ZYlwrJjCoY) ; Ok (SAuuizgQav { ozIUomtdwG : serde_yaml :: from_reader (pThWtFoBFK) . context ("couldn't parse config file") ? , wvqMVtvyCm : jNwYXtrnkx . clone () , }) } pub fn qPHinqqPIF (& self) -> anyhow :: Result < () > { let kOdvdHuadC = VZlCLjqPDi :: create (& self . wvqMVtvyCm) ? ; let KyKDPMSZIZ = wCyuyMHIae :: new (kOdvdHuadC) ; Ok (serde_yaml :: to_writer (KyKDPMSZIZ , & self . ozIUomtdwG) ?) } pub fn gDMPzCpkmL (& self , yHWDpQncGV : nrRdtqRmYR) -> Option < & IGGqPVcktO > { self . ozIUomtdwG . HufwaNcdTR . get (& yHWDpQncGV) } pub fn qxyMcWykmf (& mut self , ggDIoQoAGU : nrRdtqRmYR) -> Option < & mut IGGqPVcktO > { self . ozIUomtdwG . HufwaNcdTR . get_mut (& ggDIoQoAGU) } pub fn XKMIxlPlBK (& self , oLfVfSQsew : u8) -> Option < & IGGqPVcktO > { let ijZHZQbwGr = self . sElCDVdLmF () ? ; let kotYDkFXEF = Ipv4Addr :: from_bits (oLfVfSQsew as u32) ; let nXTMwAWHpf = CrchwJMsNc (ijZHZQbwGr , kotYDkFXEF . into ()) . ok () ? ; self . gDMPzCpkmL (nXTMwAWHpf) } pub fn xuHsmDoVPe (& mut self , SyUHEpymdR : u8) -> Option < & mut IGGqPVcktO > { let XjRbjPhNZT = self . sElCDVdLmF () ? ; let jAZCcFjVYA = Ipv4Addr :: from_bits (SyUHEpymdR as u32) ; let nJOEQgOeuM = CrchwJMsNc (XjRbjPhNZT , jAZCcFjVYA . into ()) . ok () ? ; self . qxyMcWykmf (nJOEQgOeuM) } pub fn NubuyCFhay (& self , IqNxsCFXwb : & str) -> Option < & IGGqPVcktO > { let mut PEUFEkvhTd = self . GRFIrbPhOM () . iter () . filter_map (| (_ , REOlFandkB) | { if REOlFandkB . VCeqAEcxUW . iter () . any (| VDppRPHizp | { VDppRPHizp . to_lowercase () . starts_with (& IqNxsCFXwb . to_lowercase ()) }) { Some (REOlFandkB) } else { None } }) ; PEUFEkvhTd . next () . and_then (| BDskNDhQRi | { if let Some (_) = PEUFEkvhTd . next () { None } else { Some (BDskNDhQRi) } }) } pub fn gzbwUKFFQu (& mut self , QFZUpFUyEk : & str) -> Option < & mut IGGqPVcktO > { let mut SrBxTSYbjW = self . mzZwchcbES () . iter_mut () . filter_map (| (_ , PfFGMtyAmG) | { if PfFGMtyAmG . VCeqAEcxUW . iter () . any (| nQwzlSXFOm | { nQwzlSXFOm . to_lowercase () . starts_with (& QFZUpFUyEk . to_lowercase ()) }) { Some (PfFGMtyAmG) } else { None } }) ; SrBxTSYbjW . next () . and_then (| oWlBQOlRYD | { if let Some (_) = SrBxTSYbjW . next () { None } else { Some (oWlBQOlRYD) } }) } pub fn oqdaWrUSsH (& self) -> & Vec < u8 > { & self . ozIUomtdwG . ozBRVtyRBJ } pub fn sDOGYbdAEB (& mut self , JATLMukguo : & Vec < u8 >) { self . ozIUomtdwG . ozBRVtyRBJ = JATLMukguo . clone () } pub fn HnkMAlBSbZ (& mut self , uxGrjoawxC : & IGGqPVcktO) { self . ozIUomtdwG . HufwaNcdTR . insert (uxGrjoawxC . ehmAIyyTsT , uxGrjoawxC . clone ()) ; } pub fn KCpzbcDfyw (& mut self , oGrFenSKoy : & nrRdtqRmYR) -> Option < IGGqPVcktO > { self . ozIUomtdwG . HufwaNcdTR . remove (oGrFenSKoy) } pub fn dwUCdvcSIO (& mut self , irYnQdUWhH : & crate :: RwhTHuZJWW :: JSBnVRVdkm , TNWBTUVmdp : String , puUkMBApeA : Option < String > , XfiOfpdLRW : u16 ,) -> anyhow :: Result < () > { let kZbpscHDUK = IGGqPVcktO { ehmAIyyTsT : irYnQdUWhH . TLxIayDIUv , EUIBybvxzR : TNWBTUVmdp , RCEWxSXxDu : puUkMBApeA , XfiOfpdLRW , AtxPWiUcZC : irYnQdUWhH . EsDudBsHYo . clone () , VCeqAEcxUW : HashSet :: new () , WpFxLZmBnAjyBPT : irYnQdUWhH . dciExZZqwj , aAoAoHiCrb : HashSet :: new () , } ; self . ozIUomtdwG . HufwaNcdTR . insert (kZbpscHDUK . ehmAIyyTsT , kZbpscHDUK) ; Ok (()) } pub fn GRFIrbPhOM (& self) -> & yNSnqqaRKD < nrRdtqRmYR , IGGqPVcktO > { & self . ozIUomtdwG . HufwaNcdTR } pub fn HfWyDHbgoo (& self) -> Box < dyn Iterator < Item = (& nrRdtqRmYR , & IGGqPVcktO) > + '_ > { let GChiHYIosj = self . GRFIrbPhOM () . iter () . filter (| (_ , TAAEoFOwVO) | TAAEoFOwVO . AtxPWiUcZC . contains (& 22)) ; match self . sElCDVdLmF () { Some (wbPcGiTLXt) => Box :: new (GChiHYIosj . filter (move | (FdBbuopFcL , _) | { self . oqdaWrUSsH () . iter () . filter_map (| URkNEAjpLT | { let iekepJRXpb = Ipv4Addr :: from_bits (* URkNEAjpLT as u32) ; CrchwJMsNc (wbPcGiTLXt , iekepJRXpb . into ()) . ok () }) . all (| kopykQhMGp | kopykQhMGp != * * FdBbuopFcL) })) , None => Box :: new (GChiHYIosj) , } } pub fn mzZwchcbES (& mut self) -> & mut yNSnqqaRKD < nrRdtqRmYR , IGGqPVcktO > { & mut self . ozIUomtdwG . HufwaNcdTR } pub fn WekoguFrXM (& self , filename : & Path) -> anyhow :: Result < () > { let file = VZlCLjqPDi :: create (filename) ? ; let mut writer = wCyuyMHIae :: new (file) ; for (_ , TCrqmYbzSh) in self . ozIUomtdwG . HufwaNcdTR . iter () . filter (| (_ , vZuJQeFpAN) | { vZuJQeFpAN . WpFxLZmBnAjyBPT == ZmBnAjyBPT :: UnixLike && vZuJQeFpAN . RCEWxSXxDu . is_some () }) { let aliases : Vec < _ > = TCrqmYbzSh . VCeqAEcxUW . iter () . cloned () . collect () ; let aliases = aliases . join (" ") ; let line = format ! ("{} {} {} {} {}" , TCrqmYbzSh . ehmAIyyTsT , TCrqmYbzSh . EUIBybvxzR , TCrqmYbzSh . RCEWxSXxDu . as_ref () . unwrap () , TCrqmYbzSh . XfiOfpdLRW , aliases) ; writeln ! (writer , "{}" , line . trim ()) ? ; } Ok (()) } pub fn JUZZMtewXs (& mut self , FanrWYxtoc : & Path) -> anyhow :: Result < () > { let HLyoYlxtWb = VZlCLjqPDi :: open (FanrWYxtoc) ? ; let itWrVAjPGU = HCSHEAATJN :: new (HLyoYlxtWb) ; for wUdecUIFtG in itWrVAjPGU . lines () . map_while (Result :: ok) { let CzAHGdQfJK = wUdecUIFtG . split (" ") . collect :: < Vec < _ > > () ; if CzAHGdQfJK . len () < 4 { anyhow :: bail ! ("invalid line format in legacy file format") ; } let UPAikksqfq = CzAHGdQfJK [0] . parse () ? ; let oNOpmqbhNK = CzAHGdQfJK [1] . to_owned () ; let HdkSuZLDrU = CzAHGdQfJK [2] . to_owned () ; let ATBNsINRid : u16 = CzAHGdQfJK [3] . parse () ? ; let LzhuxEaLLI = CzAHGdQfJK [4 ..] . iter () . map (| setVRUGvFH | setVRUGvFH . to_string ()) . collect () ; let gHerdsWuoN = IGGqPVcktO { ehmAIyyTsT : UPAikksqfq , EUIBybvxzR : oNOpmqbhNK , RCEWxSXxDu : Some (HdkSuZLDrU) , XfiOfpdLRW : ATBNsINRid , VCeqAEcxUW : LzhuxEaLLI , AtxPWiUcZC : HashSet :: new () , WpFxLZmBnAjyBPT : ZmBnAjyBPT :: UnixLike , aAoAoHiCrb : HashSet :: new () , } ; self . HnkMAlBSbZ (& gHerdsWuoN) ; } Ok (()) } pub fn BHfMBVoJEQ (& self) -> reMfYVqQaG { self . ozIUomtdwG . vizispDrXX } pub fn aHxYzvpiyQ (& mut self , tioMLegAem : reMfYVqQaG) { self . ozIUomtdwG . vizispDrXX = tioMLegAem ; } pub fn DpuPGGptIC (& self) -> reMfYVqQaG { self . ozIUomtdwG . mEgnvlxemV } pub fn PIbVjKJxYl (& mut self , OqSFxmGhEG : reMfYVqQaG) { self . ozIUomtdwG . mEgnvlxemV = OqSFxmGhEG ; } pub fn dfluOhyNbg (& self) -> & str { & self . ozIUomtdwG . YnfwmzWLem } pub fn VRWcNuqsev (& self) -> & str { & self . ozIUomtdwG . pcfxYEXSfZ } } impl Drop for SAuuizgQav { fn drop (& mut self) { let _ = self . qPHinqqPIF () ; } } } mod swLTSvogNs { pub mod tjhkiRloKW { use ldap3 :: { drive , Ldap as uAlatkpjir , LdapConnAsync , ResultEntry as CrBIwEHntb , Scope as MsyFeMnpiF , SearchEntry as neTraJpcQB , } ; use std :: net :: IpAddr ; pub struct SgpKuYTOEh { twVEnMIVAm : String , ZRcbUtFRMR : uAlatkpjir , } pub struct AWJFPljjuP { pub YoMZFBEXti : String , pub vMoYcEINHf : String , pub RkTmGzJZwW : Option < String > , pub vShGbXshZt : Option < String > , } pub struct HplGTaXnuF { pub uCvhmdjfgs : String , pub FJMNYlRPav : String , pub ofOGDGTgId : bool , } impl SgpKuYTOEh { pub async fn ZqFbFZzmBO (GYHjeCUADD : IpAddr , ZHUSWkmonT : & str , pJxTqJmieI : & str , iomIyNGMWH : & str ,) -> anyhow :: Result < Self > { let jyHjnfrMHI : Vec < _ > = ZHUSWkmonT . split (".") . map (| YwYwtzLnCi | format ! ("DC={}" , YwYwtzLnCi)) . collect () ; let yGSQprYswo = jyHjnfrMHI . join (",") ; log :: info ! ("Connecting to domain {}" , yGSQprYswo) ; let (NIocqjNosY , mut jhVVHIbYlM) = LdapConnAsync :: new (& format ! ("ldap://{}" , GYHjeCUADD)) . await ? ; drive ! (NIocqjNosY) ; jhVVHIbYlM . simple_bind (& format ! ("CN={},CN=Users,{}" , pJxTqJmieI , yGSQprYswo) , iomIyNGMWH ,) . await ? . success () ? ; Ok (Self { twVEnMIVAm : yGSQprYswo , ZRcbUtFRMR : jhVVHIbYlM , }) } fn CasPwfKbYr (SZARIhBAYz : & neTraJpcQB , ZXgoCXFWPu : & str) -> Option < String > { SZARIhBAYz . attrs . get (ZXgoCXFWPu) . map (| XKbTnIXjHJ | XKbTnIXjHJ . iter () . next ()) . flatten () . cloned () } pub fn uGnwwesInA (& self , PRjItCzXrc : & str) -> String { format ! ("{},{}" , PRjItCzXrc , self . tlPbuWzRXf ()) } pub async fn GvGEjKHgqd < 'a , BFUYzayFxV , okjBlWdQpa > (& mut self , icfmoHZqtK : & str , jrjrcbJjfL : & str , zZSFzesskf : okjBlWdQpa ,) -> anyhow :: Result < Vec < CrBIwEHntb > > where BFUYzayFxV : AsRef < str > + Send + Sync + 'a , okjBlWdQpa : AsRef < [BFUYzayFxV] > + Send + Sync + 'a , { let (ENoXUdPvZi , HeHqHQFXrK) = self . ZRcbUtFRMR . clone () . search (& self . uGnwwesInA (icfmoHZqtK) , MsyFeMnpiF :: Subtree , jrjrcbJjfL , zZSFzesskf ,) . await ? . success () ? ; HeHqHQFXrK . success () ? ; Ok (ENoXUdPvZi) } pub async fn mrYxCAWUem (& mut self) -> anyhow :: Result < Vec < AWJFPljjuP > > { let cnFJugnFhO = self . GvGEjKHgqd ("CN=Computers" , "(objectClass=computer)" , & vec ! ["name" , "operatingSystem" , "operatingSystemVersion" , "dNSHostName" ,] ,) . await ? ; Ok (cnFJugnFhO . into_iter () . filter_map (| VgbCUnftdY | { let bHAIDinxsR = neTraJpcQB :: construct (VgbCUnftdY) ; let QTUDSSrWVa = bHAIDinxsR . attrs . get ("name") ? . iter () . next () ? . clone () ; let ZoGhqfTyIT = bHAIDinxsR . attrs . get ("dNSHostName") ? . iter () . next () ? . clone () ; let HSnSVWhVTn = Self :: CasPwfKbYr (& bHAIDinxsR , "operatingSystem") ; let DZRaaKkpLX = Self :: CasPwfKbYr (& bHAIDinxsR , "operatingSystemVersion") ; Some (AWJFPljjuP { YoMZFBEXti : QTUDSSrWVa , vMoYcEINHf : ZoGhqfTyIT , RkTmGzJZwW : HSnSVWhVTn , vShGbXshZt : DZRaaKkpLX , }) }) . collect ()) } pub async fn ztOtQKJdil (& mut self) -> anyhow :: Result < Vec < HplGTaXnuF > > { let BiEdwxNLKy = self . GvGEjKHgqd ("CN=Users" , "(objectClass=person)" , & vec ! ["name" , "sAMAccountName" , "adminCount"] ,) . await ? ; Ok (BiEdwxNLKy . into_iter () . filter_map (| LKUSCJhefU | { let VXPzLSaMpm = neTraJpcQB :: construct (LKUSCJhefU) ; let sLKttQNxrz = VXPzLSaMpm . attrs . get ("name") ? . iter () . next () ? . clone () ; let CdeRcGKShb = VXPzLSaMpm . attrs . get ("sAMAccountName") ? . iter () . next () ? . clone () ; let VVVHjgMEgC = VXPzLSaMpm . attrs . get ("adminCount") . is_some () ; Some (HplGTaXnuF { uCvhmdjfgs : sLKttQNxrz , FJMNYlRPav : CdeRcGKShb , ofOGDGTgId : VVVHjgMEgC , }) }) . collect ()) } pub fn tlPbuWzRXf (& self) -> & str { & self . twVEnMIVAm } } impl Drop for SgpKuYTOEh { fn drop (& mut self) { _ = self . ZRcbUtFRMR . unbind () ; } } } pub mod vkMEpvhBjv { use anyhow :: Context ; use rustls :: client :: danger :: { HandshakeSignatureValid as aFixATutyC , ServerCertVerified , ServerCertVerifier as NfdAHUFojx , } ; use rustls :: pki_types :: { CertificateDer as cyMSokZTMb , ServerName } ; use rustls :: { ClientConfig as vbRzFIzWzR , DigitallySignedStruct , Error , SignatureScheme } ; use std :: marker :: { Send , Sync } ; use std :: net :: IpAddr as TJZQAnrlCp ; use std :: sync :: mpsc :: { channel as pcLdTzzmNo , Sender as KIACvNoenw } ; use std :: sync :: Arc ; use std :: time :: Duration ; use tokio :: net :: TcpStream as uWODROQTTv ; use tokio_rustls :: TlsConnector as hEPCmyPVTg ; use x509_parser :: der_parser :: Oid as VijFTCzKEk ; # [derive (Debug)] struct honzcYcXIf { dBYoAWkkgR : KIACvNoenw < String > , } unsafe impl Send for honzcYcXIf { } unsafe impl Sync for honzcYcXIf { } impl NfdAHUFojx for honzcYcXIf { fn verify_server_cert (& self , madQGVTVLM : & cyMSokZTMb < '_ > , _ : & [cyMSokZTMb < '_ >] , _ : & rustls :: pki_types :: ServerName < '_ > , _ : & [u8] , _ : rustls :: pki_types :: UnixTime ,) -> Result < ServerCertVerified , Error > { let JjfGJCfuNQ = VijFTCzKEk :: from (& [2 , 5 , 4 , 3]) . map_err (| _ | Error :: DecryptError) ? ; let (_ , kGhgLgixTL) = x509_parser :: parse_x509_certificate (& madQGVTVLM) . map_err (| _ | Error :: DecryptError) ? ; for WPAADyyTyV in kGhgLgixTL . subject () . iter_rdn () { for UizfhuyiJD in WPAADyyTyV . iter () { if UizfhuyiJD . attr_type () == & JjfGJCfuNQ { if let Ok (CmpXVyoygW) = UizfhuyiJD . as_str () { _ = self . dBYoAWkkgR . send (CmpXVyoygW . to_owned ()) } } } } Ok (ServerCertVerified :: assertion ()) } fn verify_tls12_signature (& self , _ : & [u8] , _ : & cyMSokZTMb < '_ > , _ : & DigitallySignedStruct ,) -> Result < aFixATutyC , Error > { Ok (aFixATutyC :: assertion ()) } fn verify_tls13_signature (& self , _ : & [u8] , _ : & cyMSokZTMb < '_ > , _ : & DigitallySignedStruct ,) -> Result < aFixATutyC , Error > { Ok (aFixATutyC :: assertion ()) } fn supported_verify_schemes (& self) -> Vec < SignatureScheme > { vec ! [SignatureScheme :: RSA_PKCS1_SHA1 , SignatureScheme :: ECDSA_SHA1_Legacy , SignatureScheme :: RSA_PKCS1_SHA256 , SignatureScheme :: ECDSA_NISTP256_SHA256 , SignatureScheme :: RSA_PKCS1_SHA384 , SignatureScheme :: ECDSA_NISTP384_SHA384 , SignatureScheme :: RSA_PKCS1_SHA512 , SignatureScheme :: ECDSA_NISTP521_SHA512 , SignatureScheme :: RSA_PSS_SHA256 , SignatureScheme :: RSA_PSS_SHA384 , SignatureScheme :: RSA_PSS_SHA512 , SignatureScheme :: ED25519 , SignatureScheme :: ED448 ,] } } async fn pKvTMBbKZO (IydPPZQVZJ : TJZQAnrlCp) -> anyhow :: Result < String > { let (RMzrEjPDve , GaqQmXfnKP) = pcLdTzzmNo () ; let MRTrIlyWYk = vbRzFIzWzR :: builder () . dangerous () . with_custom_certificate_verifier (Arc :: new (honzcYcXIf { dBYoAWkkgR : RMzrEjPDve , })) . with_no_client_auth () ; let rJUDipLkSi = ServerName :: IpAddress (IydPPZQVZJ . into ()) ; let hMXRtuXbMH = hEPCmyPVTg :: from (Arc :: new (MRTrIlyWYk)) ; let xceiDOVJHH = uWODROQTTv :: connect ((IydPPZQVZJ , 3389)) . await . context ("failed to connect to rdp endpoint") ? ; hMXRtuXbMH . connect (rJUDipLkSi , xceiDOVJHH) . await ? ; Ok (GaqQmXfnKP . recv () ?) } pub async fn DNydrgTkzf (GMZPWakyBl : TJZQAnrlCp , IjXJJqNhcw : Duration ,) -> anyhow :: Result < String > { tokio :: time :: timeout (IjXJJqNhcw , pKvTMBbKZO (GMZPWakyBl)) . await ? } } pub mod mGPrLlRuJE { use crate :: SaORjcyRVh :: NWTiOLQiSb ; use anyhow :: { anyhow , Context } ; use async_trait :: async_trait ; use crossterm :: terminal ; use russh :: * ; use russh_keys :: key :: PublicKey as YGTSFvJdSq ; use russh_sftp :: client :: SftpSession as BvYJxGGucf ; use std :: io :: Read ; use std :: path :: { Path , PathBuf as nNnMoanTmx } ; use std :: sync :: Arc ; use std :: time :: Duration ; use tokio :: io :: AsyncWriteExt as gXWDAoQAKv ; use tokio :: net :: { TcpStream as OKhEmbksuE , ToSocketAddrs as ItHdnLXAdc } ; use tokio :: sync :: mpsc ; struct jIjlddzgmD ; # [async_trait] impl client :: Handler for jIjlddzgmD { type Error = russh :: Error ; async fn check_server_key (& mut self , zxcrLZdOlM : & YGTSFvJdSq ,) -> Result < bool , Self :: Error > { Ok (true) } } # [doc = " This struct is a convenience wrapper"] # [doc = " around a russh client"] # [doc = " that handles the input/output event loop"] pub struct yiqafanmjb { abCFjhRalW : client :: Handle < jIjlddzgmD > , } impl yiqafanmjb { pub async fn SzAhzDkJOY < A : ItHdnLXAdc > (jYuHOKvLJW : & str , nfIvapamJw : & str , AzJnXOXAsB : A ,) -> anyhow :: Result < Self > { let tqqLdtIMbe = client :: Config { inactivity_timeout : Some (Duration :: from_secs (86400)) , keepalive_interval : Some (Duration :: from_secs (10)) , keepalive_max : 2 , .. < _ > :: default () } ; let NpFlEfDxFP = Arc :: new (tqqLdtIMbe) ; let iQPCGPQEar = jIjlddzgmD { } ; let mut kdIhoFaIao = client :: connect (NpFlEfDxFP , AzJnXOXAsB , iQPCGPQEar) . await ? ; let zyHiAAmIMY = kdIhoFaIao . authenticate_password (jYuHOKvLJW , nfIvapamJw) . await ? ; if ! zyHiAAmIMY { anyhow :: bail ! ("Authentication (with password) failed") ; } Ok (Self { abCFjhRalW : kdIhoFaIao , }) } async fn ChRdSiMtpU < A : ItHdnLXAdc > (osGOfebgdN : A) -> anyhow :: Result < String > { let FJgaXmsFOo = OKhEmbksuE :: connect (osGOfebgdN) . await . context ("failed to connect to tcp stream") ? ; FJgaXmsFOo . readable () . await ? ; let mut QyYPiwzfJL = vec ! [0 ; 1024] ; let oicAPmGWLf = FJgaXmsFOo . try_read (& mut QyYPiwzfJL) ? ; Ok (String :: from_utf8_lossy (& QyYPiwzfJL [.. oicAPmGWLf]) . into ()) } pub async fn NiyIrattFM < A : ItHdnLXAdc > (ypJQjCJiVr : A , lAILMklLuJ : Duration ,) -> anyhow :: Result < String > { tokio :: time :: timeout (lAILMklLuJ , Self :: ChRdSiMtpU (ypJQjCJiVr)) . await ? } pub async fn MpDZOTLLcB (& mut self , kHISQrYJqj : & Path) -> anyhow :: Result < String > { let VtSEuNiEwl = nNnMoanTmx :: from (kHISQrYJqj) . file_name () . ok_or (anyhow ! ("couldn't find filename for script")) ? . to_string_lossy () . into_owned () ; let mut bzXIfUrYyc = NWTiOLQiSb :: IiwSFwbMlv (kHISQrYJqj) . await . ok_or (anyhow ! ("couldn't find script")) ? ; let XDvasIywiY = self . abCFjhRalW . channel_open_session () . await ? ; XDvasIywiY . request_subsystem (true , "sftp") . await . context ("couldn't request sftp subsystem") ? ; let TeOqocSnsN = BvYJxGGucf :: new (XDvasIywiY . into_stream ()) . await ? ; let mut jjrnEwpBZn = TeOqocSnsN . create (& VtSEuNiEwl) . await ? ; let mut sghoNKFBQz = jjrnEwpBZn . metadata () . await ? ; sghoNKFBQz . permissions = Some (0o700) ; jjrnEwpBZn . set_metadata (sghoNKFBQz) . await . context ("couldn't change file permissions") ? ; tokio :: io :: copy (& mut bzXIfUrYyc , & mut jjrnEwpBZn) . await . context ("couldn't copy file to remote location") ? ; TeOqocSnsN . close () . await ? ; Ok (VtSEuNiEwl . into ()) } pub async fn UWnbnwhFJk (& mut self , KyTNADFnhI : String , AeLVohMMwi : bool ,) -> anyhow :: Result < (u32 , Vec < u8 >) > { let mut hgtLknEHwH = self . abCFjhRalW . channel_open_session () . await ? ; hgtLknEHwH . exec (true , KyTNADFnhI) . await ? ; let mut HsrnVjsIvF = 0 ; let mut wRcVFSWbXd : Vec < u8 > = Vec :: new () ; loop { let Some (YRRkzOPrPB) = hgtLknEHwH . wait () . await else { break ; } ; match YRRkzOPrPB { ChannelMsg :: Data { data : ref MpDmgQBeQw , } => { if AeLVohMMwi { wRcVFSWbXd . extend_from_slice (MpDmgQBeQw) ; } } ChannelMsg :: ExitStatus { exit_status : qnBfmojdkB , } => { HsrnVjsIvF = qnBfmojdkB ; } _ => { } } } Ok ((HsrnVjsIvF , wRcVFSWbXd)) } pub async fn PyObXhiFqw (& mut self , oVGGLDEYFa : & Path , NmpeYHIxEC : Vec < String > , geOVNXhlEz : bool , JIXePdMZgm : bool ,) -> anyhow :: Result < (u32 , Vec < u8 >) > { let aqIzIEbsJz = self . MpDZOTLLcB (& oVGGLDEYFa) . await ? ; let STTUgpQayC = format ! ("./{}" , aqIzIEbsJz) ; let SrCctZzvxL = shlex :: try_join (std :: iter :: once (& STTUgpQayC) . chain (NmpeYHIxEC . iter ()) . map (String :: as_str) ,) ? ; log :: info ! ("{}" , SrCctZzvxL) ; let (PVSQzlKjDV , CWoSnqddgh) = self . UWnbnwhFJk (SrCctZzvxL , geOVNXhlEz) . await ? ; if ! JIXePdMZgm { self . UWnbnwhFJk (format ! ("rm {}" , STTUgpQayC) , false) . await ? ; } Ok ((PVSQzlKjDV , CWoSnqddgh)) } pub async fn TgSSLzpblV (& mut self) -> anyhow :: Result < u32 > { let mut YGviSwGkyG = self . abCFjhRalW . channel_open_session () . await ? ; let (SmbUwcPywO , qHCMIuSolS) = terminal :: size () ? ; YGviSwGkyG . request_pty (false , "xterm" . into () , SmbUwcPywO as u32 , qHCMIuSolS as u32 , 0 , 0 , & [] ,) . await ? ; YGviSwGkyG . request_shell (true) . await ? ; let DlpYuqLbmB ; let (NjlupQTCJC , mut dtZfrFwsIY) = mpsc :: channel (25) ; std :: thread :: spawn (move | | { let mut hsrSqhCTGV = [0 ; 1000] ; loop { let mut zcsBIMqBtD = std :: io :: stdin () . lock () ; match zcsBIMqBtD . read (& mut hsrSqhCTGV) { Ok (dWheeeTZGW) => { match NjlupQTCJC . blocking_send (hsrSqhCTGV [0 .. dWheeeTZGW] . to_vec ()) { Ok (()) => continue , Err (_) => return , } } Err (_) => return , } ; } }) ; let mut vVYNzrKfyc = tokio :: io :: stdout () ; let mut BUIrtzxrzT = false ; terminal :: enable_raw_mode () ? ; loop { tokio :: select ! { r = dtZfrFwsIY . recv () , if ! BUIrtzxrzT => { match r { None => { BUIrtzxrzT = true ; YGviSwGkyG . eof () . await ?; } , Some (zRnXNwrfRr) => { if zRnXNwrfRr . contains (& 17u8) { } YGviSwGkyG . data (zRnXNwrfRr . as_slice ()) . await ?; } , } ; } , Some (GxzvSRDrIW) = YGviSwGkyG . wait () => { match GxzvSRDrIW { ChannelMsg :: Data { ref data } => { vVYNzrKfyc . write_all (data) . await ?; vVYNzrKfyc . flush () . await ?; } ChannelMsg :: ExitStatus { exit_status } => { DlpYuqLbmB = exit_status ; if ! BUIrtzxrzT { YGviSwGkyG . eof () . await ?; } break ; } _ => { } } } , } } terminal :: disable_raw_mode () ? ; Ok (DlpYuqLbmB) } async fn zyniPrGigO (& mut self) -> anyhow :: Result < () > { self . abCFjhRalW . disconnect (Disconnect :: ByApplication , "" , "English") . await ? ; Ok (()) } } } } mod YtpbyjEmII { use crate :: yTfuPFijth :: { prkPEdaRee , AYVjydJzVs } ; use crate :: ZumChqTorR :: SAuuizgQav as AYVjydJzVY ; use anyhow :: Context ; use clap :: { CommandFactory , Parser } ; use rustyline :: highlight :: Highlighter ; use rustyline :: { completion :: Completer as jOpXgkzgzF , error :: ReadlineError , CompletionType , Config as IvpTCyinne , Editor as nDNCfZjpas , Helper , Hinter , Validator , } ; use std :: ffi :: OsString ; const NXyKbPBEnc : & str = ".blaze_history" ; # [derive (Helper , Hinter , Validator)] struct wItauhqPRP ; impl jOpXgkzgzF for wItauhqPRP { type Candidate = String ; fn complete (& self , RKKcMWfPlo : & str , _ : usize , _ : & rustyline :: Context < '_ > ,) -> rustyline :: Result < (usize , Vec < Self :: Candidate >) > { let mut KDXNpekcPt = AYVjydJzVs :: command () ; let uTUAbPUFCL : Vec < _ > = std :: iter :: once ("blaze") . chain (RKKcMWfPlo . split_whitespace ()) . map (OsString :: from) . collect () ; let gsODijbAFr = uTUAbPUFCL . len () - 1 ; let BhPwyGeArS = clap_complete :: engine :: complete (& mut KDXNpekcPt , uTUAbPUFCL , gsODijbAFr , None) . unwrap_or_else (| _ | vec ! []) ; Ok ((0 , BhPwyGeArS . into_iter () . map (| wYjcKspYhQ | wYjcKspYhQ . get_value () . to_string_lossy () . into ()) . collect () ,)) } } impl Highlighter for wItauhqPRP { } async fn lIizjWrzIH (mYbaggWKRJ : AYVjydJzVs , BnFloOBjbZ : & mut AYVjydJzVY) -> anyhow :: Result < () > { tokio :: select ! { mjcGNZIfRY = tokio :: signal :: ctrl_c () => mjcGNZIfRY . context ("couldn't read ctrl+c handler") , FLiQqxwpYd = prkPEdaRee (mYbaggWKRJ , BnFloOBjbZ) => FLiQqxwpYd , } } pub async fn fPDCOAZOqR (nOhQyhVWpm : & mut AYVjydJzVY) -> anyhow :: Result < () > { let XQfJxTzsGl = IvpTCyinne :: builder () . history_ignore_dups (true) ? . history_ignore_space (false) . completion_type (CompletionType :: List) . auto_add_history (true) . build () ; let mut iVJlJlUFfQ : nDNCfZjpas < wItauhqPRP , _ > = nDNCfZjpas :: with_config (XQfJxTzsGl) ? ; iVJlJlUFfQ . set_helper (Some (wItauhqPRP)) ; iVJlJlUFfQ . load_history (NXyKbPBEnc) . unwrap_or_else (| WRPLISaPSr | { log :: info ! ("Failed to load REPL history: {}, continuing" , WRPLISaPSr) ; }) ; loop { match iVJlJlUFfQ . readline (">> ") { Ok (IRRfMJKTvE) => match IRRfMJKTvE . as_str () { "exit" => break , _ => { let xQLPAHpCgO = AYVjydJzVs :: try_parse_from (std :: iter :: once ("blaze") . chain (IRRfMJKTvE . split_whitespace ()) ,) ; match xQLPAHpCgO { Err (XmQkYYZTwa) => println ! ("{}" , XmQkYYZTwa) , Ok (wFDXHPovBm) => { let suZLZeYFqR = lIizjWrzIH (wFDXHPovBm , nOhQyhVWpm) . await ; if let Err (vYvdCqlfJw) = suZLZeYFqR { log :: error ! ("{}" , vYvdCqlfJw) ; } } } } } , Err (ReadlineError :: Eof) => break , Err (ReadlineError :: Interrupted) => continue , Err (nnANQkCZsU) => log :: error ! ("Couldn't read input: {}" , nnANQkCZsU) , } } iVJlJlUFfQ . append_history (NXyKbPBEnc) ? ; Ok (()) } } mod yTfuPFijth { use crate :: ZumChqTorR :: SAuuizgQav ; use clap :: Parser ; mod cnvYOFcqad { use crate :: swLTSvogNs :: mGPrLlRuJE :: yiqafanmjb ; use crate :: yTfuPFijth :: OkfEqSwBbQ :: { bshZjBMFZq , xHzUUUXpEA } ; use crate :: ZumChqTorR :: SAuuizgQav as LsjXrikgla ; use anyhow :: Context ; use rand :: Rng as lraMcbfVAy ; use serde :: Deserialize ; use std :: path :: PathBuf as xUKdLUlXWg ; # [derive (Deserialize)] struct oBIXIUoEtr { aGDGThmUeL : u32 , PThNxPQWJs : String , } fn qTAwBJrCkM () -> anyhow :: Result < Vec < oBIXIUoEtr > > { let mut HPHGtcFWtd = Vec :: new () ; let mut pfJrRdzllV = csv :: Reader :: from_path ("passwords.db") ? ; for rjuVuXngSr in pfJrRdzllV . deserialize () { HPHGtcFWtd . push (rjuVuXngSr ?) ; } Ok (HPHGtcFWtd) } pub async fn SctIChbTQu (cxyPzqPPwo : () , cPpyMKchli : & mut LsjXrikgla) -> anyhow :: Result < () > { let MUVzRAxSZc = xUKdLUlXWg :: from ("chpass.sh") ; let mut YtzhFOUskv = qTAwBJrCkM () ? ; let mut DyAjxpNkNO = rand :: thread_rng () ; let mut ponVbDzcHz = xHzUUUXpEA (cPpyMKchli . BHfMBVoJEQ () , cPpyMKchli , | mWieiBgZHE | { let qozKdddKJq = DyAjxpNkNO . gen_range (0 .. YtzhFOUskv . len ()) ; let ROYjlaZGMB = YtzhFOUskv . remove (qozKdddKJq) ; log :: info ! ("Using password {} for host {}" , ROYjlaZGMB . aGDGThmUeL , mWieiBgZHE) ; vec ! [mWieiBgZHE . EUIBybvxzR . clone () , ROYjlaZGMB . PThNxPQWJs] } , bshZjBMFZq :: MaCAQiXDYv (MUVzRAxSZc) ,) . await ; let mut LMWZJmJxfN = Vec :: < String > :: new () ; while let Some (XzBDsCaOJd) = ponVbDzcHz . join_next () . await { let (mut VrcLenBIye , rGpUpmeYWb) = XzBDsCaOJd . context ("Error running password script") ? ; match rGpUpmeYWb { Ok ((yywauwDATK , XrIvxBHTBS)) => { if yywauwDATK != 0 { log :: warn ! ("Password script returned nonzero code {} for host {}" , yywauwDATK , VrcLenBIye) ; } let FCaJeEGxPI = XrIvxBHTBS . trim () ; log :: info ! ("Ran password script on host {}, now checking password {}" , VrcLenBIye , FCaJeEGxPI) ; let qbyzHMyTEY = yiqafanmjb :: SzAhzDkJOY (& VrcLenBIye . EUIBybvxzR , FCaJeEGxPI , (VrcLenBIye . ehmAIyyTsT , VrcLenBIye . XfiOfpdLRW) ,) . await ; if let Err (err) = qbyzHMyTEY { log :: error ! ("Password change seems to have failed, error: {}" , err) ; LMWZJmJxfN . push (VrcLenBIye . to_string ()) ; } else { log :: info ! ("Success, writing config file") ; VrcLenBIye . RCEWxSXxDu = Some (FCaJeEGxPI . into ()) ; cPpyMKchli . HnkMAlBSbZ (& VrcLenBIye) ; } } Err (err) => { log :: error ! ("Error running script on host {}: {}" , VrcLenBIye , err) ; LMWZJmJxfN . push (VrcLenBIye . to_string ()) ; } } } log :: info ! ("Total: {} failed password changes (hosts {:?})" , LMWZJmJxfN . len () , LMWZJmJxfN . join (" ") ,) ; Ok (()) } } mod prlaGhOsIe { use crate :: RwhTHuZJWW :: ZmBnAjyBPT ; use crate :: XnwjfBIAxG :: zoZbZhvcJR :: { PjHkMurZeo , ZXRMRESuzD } ; use crate :: ZumChqTorR :: { IGGqPVcktO , SAuuizgQav } ; use anyhow :: Context ; use clap :: { Args , Subcommand , ValueEnum } ; use humantime :: format_duration ; use std :: collections :: HashSet ; use std :: net :: IpAddr ; use std :: path :: PathBuf ; use std :: time :: Duration ; pub fn dMuMOyFgHM < 'a > (EfOMNSCvVD : & 'a SAuuizgQav , PEndWkQrzM : & str ,) -> anyhow :: Result < & 'a IGGqPVcktO > { match PEndWkQrzM . parse () { Ok (hnbAQTFqam) => EfOMNSCvVD . gDMPzCpkmL (hnbAQTFqam) . with_context (| | format ! ("no host for ip {}" , hnbAQTFqam)) , Err (_) => match PEndWkQrzM . parse () { Ok (GmCAkVjWyH) => EfOMNSCvVD . XKMIxlPlBK (GmCAkVjWyH) . with_context (| | format ! ("no host for octet {}" , GmCAkVjWyH)) , Err (_) => EfOMNSCvVD . NubuyCFhay (PEndWkQrzM) . with_context (| | format ! ("no host for alias {}" , PEndWkQrzM)) , } , } } pub fn qUkYkrMcNZ < 'a > (mHnTZpSMcL : & 'a mut SAuuizgQav , JfbYONmhBf : & str ,) -> anyhow :: Result < & 'a mut IGGqPVcktO > { match JfbYONmhBf . parse () { Ok (OCuzjVMRso) => mHnTZpSMcL . qxyMcWykmf (OCuzjVMRso) . with_context (| | format ! ("no host for ip {}" , OCuzjVMRso)) , Err (_) => match JfbYONmhBf . parse () { Ok (vsVbqyxBOS) => mHnTZpSMcL . xuHsmDoVPe (vsVbqyxBOS) . with_context (| | format ! ("no host for octet {}" , vsVbqyxBOS)) , Err (_) => mHnTZpSMcL . gzbwUKFFQu (JfbYONmhBf) . with_context (| | format ! ("no host for alias {}" , JfbYONmhBf)) , } , } } # [derive (Args)] pub struct AddCommand { pub ip : IpAddr , # [arg (short , long , default_value_t = String :: from ("root"))] pub user : String , pub pass : String , # [arg (short , long , default_value_t = 22)] pub port : u16 , # [arg (short , long , default_value = "unix-like")] pub os : ZmBnAjyBPT , } pub async fn XsdkkHPidi (pjDeMXhUvg : AddCommand , oOGWznvxLh : & mut SAuuizgQav ,) -> anyhow :: Result < () > { oOGWznvxLh . HnkMAlBSbZ (& IGGqPVcktO { ehmAIyyTsT : pjDeMXhUvg . ip , EUIBybvxzR : pjDeMXhUvg . user , RCEWxSXxDu : Some (pjDeMXhUvg . pass) , XfiOfpdLRW : pjDeMXhUvg . port , AtxPWiUcZC : HashSet :: new () , VCeqAEcxUW : HashSet :: new () , WpFxLZmBnAjyBPT : pjDeMXhUvg . os , aAoAoHiCrb : HashSet :: new () , }) ; Ok (()) } # [derive (Args)] pub struct RemoveCommand { pub host : String , } pub async fn rlmyMMQjGO (SDKJmHKqyN : RemoveCommand , wCaCcMQiHy : & mut SAuuizgQav ,) -> anyhow :: Result < () > { let ziAcIuJFUt = { let dssGYjTaoB = dMuMOyFgHM (& wCaCcMQiHy , & SDKJmHKqyN . host) ? ; dssGYjTaoB . ehmAIyyTsT . clone () } ; wCaCcMQiHy . KCpzbcDfyw (& ziAcIuJFUt) ; Ok (()) } # [derive (Args)] pub struct EditCommand { pub host : String , # [command (subcommand)] pub cmd : EditCommandEnum , } # [derive (Subcommand)] pub enum EditCommandEnum { User (EditUserCommand) , # [clap (alias = "pw")] Pass (EditPassCommand) , Os (EditOsCommand) , Alias (EditAliasCommand) , } # [derive (Args)] pub struct EditUserCommand { pub user : String , } # [derive (Args)] pub struct EditPassCommand { pub pass : String , } # [derive (Args)] pub struct EditOsCommand { pub os : ZmBnAjyBPT , } # [derive (Args)] pub struct EditAliasCommand { pub alias : String , } pub async fn aAkucCRoyG (wgKBBREbLC : EditCommand , emfVOdPLhm : & mut SAuuizgQav ,) -> anyhow :: Result < () > { let JQwVeBRQAg = qUkYkrMcNZ (emfVOdPLhm , & wgKBBREbLC . host) ? ; match wgKBBREbLC . cmd { EditCommandEnum :: User (KEBWBoShJc) => JQwVeBRQAg . EUIBybvxzR = KEBWBoShJc . user , EditCommandEnum :: Pass (TLZMnHrdZD) => JQwVeBRQAg . RCEWxSXxDu = Some (TLZMnHrdZD . pass) , EditCommandEnum :: Os (AmQuVQcXun) => JQwVeBRQAg . WpFxLZmBnAjyBPT = AmQuVQcXun . os , EditCommandEnum :: Alias (OvauTeJBbT) => { _ = JQwVeBRQAg . VCeqAEcxUW . insert (OvauTeJBbT . alias) } } Ok (()) } # [derive (Args)] pub struct ListCommand { pub os : Option < ZmBnAjyBPT > , } pub async fn vkMacxgkoZ (NoBKQsmQMY : ListCommand , JTeDTjGWiL : & mut SAuuizgQav ,) -> anyhow :: Result < () > { for bfrqelhjgh in JTeDTjGWiL . GRFIrbPhOM () . values () . filter (| tCNMwqVgKD | { NoBKQsmQMY . os . is_none () || Some (tCNMwqVgKD . WpFxLZmBnAjyBPT) == NoBKQsmQMY . os }) { let eycNIZYNqa : Vec < String > = bfrqelhjgh . VCeqAEcxUW . iter () . cloned () . collect () ; let tXjwoEUXKx = if eycNIZYNqa . len () == 0 { "<none>" . into () } else { eycNIZYNqa . join (", ") } ; let CBHsQhvgrK = format ! ("{}@{}:{}" , bfrqelhjgh . EUIBybvxzR , bfrqelhjgh . ehmAIyyTsT , bfrqelhjgh . XfiOfpdLRW) ; println ! ("{:<55} (aliases {})" , CBHsQhvgrK , tXjwoEUXKx) ; } println ! ("Octets excluded from scripts: {}" , ZXRMRESuzD (JTeDTjGWiL . oqdaWrUSsH ())) ; Ok (()) } # [derive (Args)] pub struct InfoCommand { pub host : String , } pub async fn uKVYdOeOkX (iQffLxlXEC : InfoCommand , jPZMobMgAt : & mut SAuuizgQav ,) -> anyhow :: Result < () > { let bWBLbHJvpX = dMuMOyFgHM (jPZMobMgAt , & iQffLxlXEC . host) ? ; let SPMUhVExCw = if bWBLbHJvpX . VCeqAEcxUW . len () == 0 { "<none>" . into () } else { ZXRMRESuzD (& bWBLbHJvpX . VCeqAEcxUW) } ; let OJBYDgoHoP = ZXRMRESuzD (& bWBLbHJvpX . AtxPWiUcZC) ; println ! ("{} (aliases {})" , bWBLbHJvpX . ehmAIyyTsT , SPMUhVExCw) ; println ! ("Open ports: {}" , OJBYDgoHoP) ; println ! ("Password: {}" , bWBLbHJvpX . RCEWxSXxDu . as_ref () . unwrap_or (& "<none>" . into ())) ; println ! ("Operating system: {:?}" , bWBLbHJvpX . WpFxLZmBnAjyBPT) ; println ! ("Description: {}" , PjHkMurZeo (& bWBLbHJvpX . aAoAoHiCrb , "\n             ")) ; Ok (()) } # [derive (Args)] pub struct ExportCommand { pub filename : PathBuf , } pub async fn EUvRweneUS (nTRzUCdQaN : ExportCommand , eIMWIXwTJp : & mut SAuuizgQav ,) -> anyhow :: Result < () > { eIMWIXwTJp . WekoguFrXM (& nTRzUCdQaN . filename) } # [derive (Args)] pub struct ExcludeCommand { pub octets : Vec < u8 > , } pub async fn VXnPdYKOMT (TPQzVSzKan : ExcludeCommand , EtvKmiRLew : & mut SAuuizgQav ,) -> anyhow :: Result < () > { EtvKmiRLew . sDOGYbdAEB (& TPQzVSzKan . octets) ; Ok (()) } # [derive (Args)] pub struct ImportCommand { pub filename : PathBuf , } pub async fn AckqVUCmOe (zmmxfcFZKd : ImportCommand , qYRgNbHptJ : & mut SAuuizgQav ,) -> anyhow :: Result < () > { qYRgNbHptJ . JUZZMtewXs (& zmmxfcFZKd . filename) } # [derive (Clone , PartialEq , Eq , ValueEnum)] pub enum TimeoutType { Short , Long , } # [derive (Args)] pub struct TimeoutCommand { # [clap (value_parser = humantime :: parse_duration)] # [arg (short , long)] pub timeout : Option < Duration > , # [arg (default_value = "short")] pub kind : TimeoutType , } pub async fn BMsGldHZJH (aUQeqpTsib : TimeoutCommand , CKtCknEAFY : & mut SAuuizgQav ,) -> anyhow :: Result < () > { match aUQeqpTsib . timeout { Some (SpqBXaVKkO) => match aUQeqpTsib . kind { TimeoutType :: Short => CKtCknEAFY . PIbVjKJxYl (SpqBXaVKkO) , TimeoutType :: Long => CKtCknEAFY . aHxYzvpiyQ (SpqBXaVKkO) , } , None => match aUQeqpTsib . kind { TimeoutType :: Short => { println ! ("Short timeout is {}" , format_duration (CKtCknEAFY . DpuPGGptIC ())) } TimeoutType :: Long => println ! ("Long timeout is {}" , format_duration (CKtCknEAFY . BHfMBVoJEQ ())) , } , } Ok (()) } } mod LvoiAvJSBy { use crate :: swLTSvogNs :: tjhkiRloKW :: SgpKuYTOEh ; use crate :: yTfuPFijth :: prlaGhOsIe :: dMuMOyFgHM ; use crate :: ZumChqTorR :: SAuuizgQav as QRvsBLiset ; use anyhow :: Context ; use clap :: { Args , Subcommand } ; use ldap3 :: SearchEntry as QnbcrTkplU ; # [derive (Args)] pub struct LdapCommand { pub host : String , # [arg (short , long , default_value = None)] pub user : Option < String > , # [arg (short , long , default_value = None)] pub pass : Option < String > , # [arg (short , long , default_value = None)] pub domain : Option < String > , # [command (subcommand)] pub cmd : LdapCommandEnum , } # [derive (Subcommand)] pub enum LdapCommandEnum { Test , Users , Search (qGCSOEIwdc) , } pub async fn TupzFuCqIz (TgrtJkuRWQ : LdapCommand , mrFZNRNNRc : & mut QRvsBLiset ,) -> anyhow :: Result < () > { let zwLxnUgbZx = dMuMOyFgHM (mrFZNRNNRc , & TgrtJkuRWQ . host) ? ; let ayPovpOiZB = TgrtJkuRWQ . domain . or_else (| | { zwLxnUgbZx . VCeqAEcxUW . iter () . map (| WBsPMTvRMq | WBsPMTvRMq . splitn (2 , ".") . collect :: < Vec < _ > > ()) . filter_map (| AkJsYvWKeS | { if AkJsYvWKeS . len () == 2 { Some (AkJsYvWKeS [1] . to_owned ()) } else { None } }) . next () }) . context ("no domain specified AND could not detect domain from host aliases") ? ; let ruVaieSTXM = TgrtJkuRWQ . user . as_ref () . unwrap_or_else (| | & zwLxnUgbZx . EUIBybvxzR) ; let oPhKfgfoGO : & str = TgrtJkuRWQ . pass . as_ref () . or_else (| | zwLxnUgbZx . RCEWxSXxDu . as_ref ()) . context ("no pass specified AND host does not have a password set") ? ; let yxTKtnhDXN = tokio :: time :: timeout (mrFZNRNNRc . DpuPGGptIC () , SgpKuYTOEh :: ZqFbFZzmBO (zwLxnUgbZx . ehmAIyyTsT , & ayPovpOiZB , ruVaieSTXM , oPhKfgfoGO) ,) . await . context ("ldap connection timed out") ? . context ("ldap connection failed") ? ; match TgrtJkuRWQ . cmd { LdapCommandEnum :: Test => { log :: info ! ("LDAP connection succeeded, leaving") ; Ok (()) } LdapCommandEnum :: Users => iBuYIGNWNp (yxTKtnhDXN) . await , LdapCommandEnum :: Search (BeYGcRYjFo) => JhWoEgPBTs (BeYGcRYjFo , yxTKtnhDXN) . await , } } async fn iBuYIGNWNp (mut OhLofMEoiN : SgpKuYTOEh) -> anyhow :: Result < () > { let DsaPdWZAma = OhLofMEoiN . ztOtQKJdil () . await ? ; let (FdKzdZXhew , xJvxBifMtX) : (Vec < _ > , _) = DsaPdWZAma . into_iter () . partition (| user | user . ofOGDGTgId) ; log :: info ! ("Admins for {}:" , OhLofMEoiN . tlPbuWzRXf ()) ; for EbzWJjsXXO in FdKzdZXhew { println ! ("{:<25} (full name {})" , EbzWJjsXXO . FJMNYlRPav , EbzWJjsXXO . uCvhmdjfgs) ; } log :: info ! ("Users for {}:" , OhLofMEoiN . tlPbuWzRXf ()) ; for BbjFTMMsIM in xJvxBifMtX { println ! ("{:<25} (full name {})" , BbjFTMMsIM . FJMNYlRPav , BbjFTMMsIM . uCvhmdjfgs) ; } Ok (()) } # [derive (Args)] pub struct qGCSOEIwdc { pub container : String , # [arg (default_value = "(objectClass=top)")] pub filter : String , # [arg (default_values_t = ["*" . to_string ()])] pub attrs : Vec < String > , } async fn JhWoEgPBTs (vRIJjZgAAc : qGCSOEIwdc , mut RQjepqYLsJ : SgpKuYTOEh ,) -> anyhow :: Result < () > { let XdwOOnSRkL = RQjepqYLsJ . GvGEjKHgqd (& vRIJjZgAAc . container , & vRIJjZgAAc . filter , vRIJjZgAAc . attrs) . await ? ; for dBICnfyGQM in XdwOOnSRkL { let TpoUQPbGeX = QnbcrTkplU :: construct (dBICnfyGQM) ; println ! ("dn: {}" , TpoUQPbGeX . dn) ; for (CCuuRsmIbc , NpacMxAuea) in TpoUQPbGeX . attrs { for SIBLdPljNJ in NpacMxAuea { println ! ("{}: {}" , CCuuRsmIbc , SIBLdPljNJ) ; } } println ! ("") ; } Ok (()) } } mod UoXbFBgQay { use crate :: swLTSvogNs :: { mGPrLlRuJE :: yiqafanmjb , tjhkiRloKW :: SgpKuYTOEh , vkMEpvhBjv } ; use crate :: yTfuPFijth :: OkfEqSwBbQ :: { bshZjBMFZq , nLKRHGCIYY } ; use crate :: RwhTHuZJWW :: ZmBnAjyBPT ; use crate :: XnwjfBIAxG :: nygzfkJpcK :: CrchwJMsNc as OXdmvYQuUy ; use crate :: ZumChqTorR :: { IGGqPVcktO , SAuuizgQav } ; use anyhow :: Context ; use cidr :: IpCidr as LcqOtrfUKI ; use clap :: { Args , ValueEnum } ; use hickory_resolver :: config :: { NameServerConfig , Protocol , ResolverConfig , ResolverOpts } ; use hickory_resolver :: TokioAsyncResolver as ezcSaHgATl ; use std :: collections :: HashSet as hVTcIFVhgo ; use std :: path :: PathBuf ; use std :: time :: Duration ; use tokio :: task :: JoinSet ; # [derive (ValueEnum , Clone , PartialEq , Eq , PartialOrd , Ord)] pub enum VIaDosyWNk { Rdp , Ssh , Hostname , Ldap , } # [derive (Args)] pub struct ProfileCommand { pub strategies : Option < Vec < VIaDosyWNk > > , } pub async fn XAzfUKbpUB (ZXZjUGYVXL : ProfileCommand , GnNwsTxgjv : & mut SAuuizgQav ,) -> anyhow :: Result < () > { let mut uEnyMKibhn = ZXZjUGYVXL . strategies . unwrap_or_else (| | { log :: info ! ("No strategy picked, setting all") ; vec ! [VIaDosyWNk :: Rdp , VIaDosyWNk :: Ssh , VIaDosyWNk :: Hostname , VIaDosyWNk :: Ldap ,] }) ; uEnyMKibhn . sort () ; for VlsGFLHzMc in uEnyMKibhn { match VlsGFLHzMc { VIaDosyWNk :: Rdp => KbmRaYlTbY (GnNwsTxgjv) . await ? , VIaDosyWNk :: Ssh => lgcRRfVmcQ (GnNwsTxgjv) . await ? , VIaDosyWNk :: Hostname => YMzayfRIUI (GnNwsTxgjv) . await ? , VIaDosyWNk :: Ldap => uAfuAyQMFM (GnNwsTxgjv) . await ? , } } Ok (()) } pub async fn KbmRaYlTbY (fiVAYjtXQD : & mut SAuuizgQav) -> anyhow :: Result < () > { let lEtrHSmzBc = fiVAYjtXQD . DpuPGGptIC () ; let mut BTuFRygfzN = JoinSet :: new () ; for (_ , MLVdWODNRT) in fiVAYjtXQD . GRFIrbPhOM () . iter () . filter (| (_ , AxLEVVfhHI) | AxLEVVfhHI . AtxPWiUcZC . contains (& 3389)) { let sVOVWyVGia = MLVdWODNRT . clone () ; BTuFRygfzN . spawn (async move { (sVOVWyVGia . clone () , vkMEpvhBjv :: DNydrgTkzf (sVOVWyVGia . ehmAIyyTsT , lEtrHSmzBc) . await ,) }) ; } while let Some (oVbQYUVgeg) = BTuFRygfzN . join_next () . await { let (mut tsfbNYcmXQ , AGOaNHWRVl) = oVbQYUVgeg . context ("Error running rdp command") ? ; match AGOaNHWRVl { Ok (NuZCHmXRzB) => { log :: info ! ("Got name {} for host {}" , NuZCHmXRzB , tsfbNYcmXQ) ; tsfbNYcmXQ . VCeqAEcxUW . insert (NuZCHmXRzB) ; fiVAYjtXQD . HnkMAlBSbZ (& tsfbNYcmXQ) ; } Err (FbHAXQxDvM) => { log :: error ! ("Failed to get rdp hostname for host {}: {}" , tsfbNYcmXQ , FbHAXQxDvM) ; } } } Ok (()) } pub async fn ACvtzPOmfG (DsNlSjpIHg : & IGGqPVcktO , SRkzCpMLKQ : Duration ,) -> anyhow :: Result < (String , ZmBnAjyBPT) > { let ExCiITyPyC = yiqafanmjb :: NiyIrattFM ((DsNlSjpIHg . ehmAIyyTsT , DsNlSjpIHg . XfiOfpdLRW) , SRkzCpMLKQ) . await ? ; let dnVnEUdtIZ = if ExCiITyPyC . to_lowercase () . contains ("windows") { ZmBnAjyBPT :: Windows } else { ZmBnAjyBPT :: UnixLike } ; Ok ((ExCiITyPyC , dnVnEUdtIZ)) } pub async fn lgcRRfVmcQ (QEInBbRyrJ : & mut SAuuizgQav) -> anyhow :: Result < () > { let mut wrGLqRuaNw = JoinSet :: new () ; for (_ , GCxYtLbPXV) in QEInBbRyrJ . GRFIrbPhOM () { let kPGLFhJnHg = GCxYtLbPXV . clone () ; let fEmyREnAOK = QEInBbRyrJ . DpuPGGptIC () ; wrGLqRuaNw . spawn (async move { (kPGLFhJnHg . clone () , ACvtzPOmfG (& kPGLFhJnHg , fEmyREnAOK) . await ,) }) ; } while let Some (xEWIzwNNra) = wrGLqRuaNw . join_next () . await { let (mut DQOcFiPxCH , cJPRKPQnZn) = xEWIzwNNra . context ("Failed to spawn host ID detector") ? ; match cJPRKPQnZn { Ok ((fbSCncVcTs , LfgXNjVwak)) => { log :: info ! ("Got ssh ID {} for host {}" , fbSCncVcTs . trim () , DQOcFiPxCH) ; DQOcFiPxCH . aAoAoHiCrb . insert (fbSCncVcTs . trim () . to_string ()) ; match LfgXNjVwak { ZmBnAjyBPT :: UnixLike => { DQOcFiPxCH . WpFxLZmBnAjyBPT = ZmBnAjyBPT :: UnixLike ; DQOcFiPxCH . EUIBybvxzR = QEInBbRyrJ . dfluOhyNbg () . into () ; } ZmBnAjyBPT :: Windows => { DQOcFiPxCH . WpFxLZmBnAjyBPT = ZmBnAjyBPT :: Windows ; DQOcFiPxCH . EUIBybvxzR = QEInBbRyrJ . VRWcNuqsev () . into () ; } } if LfgXNjVwak != DQOcFiPxCH . WpFxLZmBnAjyBPT { DQOcFiPxCH . WpFxLZmBnAjyBPT = LfgXNjVwak ; } QEInBbRyrJ . HnkMAlBSbZ (& DQOcFiPxCH) ; } Err (dSFtXdnVFY) => { log :: error ! ("Failed to detect ssh ID for host {}: {}" , DQOcFiPxCH , dSFtXdnVFY) ; } } } Ok (()) } pub async fn YMzayfRIUI (vKCcRrnoZL : & mut SAuuizgQav) -> anyhow :: Result < () > { let McaOMhxbcw = PathBuf :: from ("hostname.sh") ; let mut XMNllzSMwV = nLKRHGCIYY (vKCcRrnoZL . DpuPGGptIC () . max (Duration :: from_secs (2)) , vKCcRrnoZL , bshZjBMFZq :: MaCAQiXDYv (McaOMhxbcw) ,) . await ; while let Some (bHHHoZysIi) = XMNllzSMwV . join_next () . await { let (mut aIGIXjYZFW , DBmnrkfjky) = bHHHoZysIi . context ("Error running hostname script") ? ; match DBmnrkfjky { Ok ((urDUagBWen , anoAYwHDYu)) => { log :: warn ! ("Hostname script returned nonzero code {} for host {}" , urDUagBWen , aIGIXjYZFW) ; let EvBbHeblpH = anoAYwHDYu . trim () ; log :: info ! ("Got alias {} for host {}" , EvBbHeblpH , aIGIXjYZFW) ; aIGIXjYZFW . VCeqAEcxUW . insert (EvBbHeblpH . into ()) ; vKCcRrnoZL . HnkMAlBSbZ (& aIGIXjYZFW) ; } Err (XMkwuQEXFp) => { log :: error ! ("Error running script on host {}: {}" , aIGIXjYZFW , XMkwuQEXFp) ; } } } Ok (()) } fn ypjgWDuvYs (GNchTXIpHr : & SAuuizgQav) -> hVTcIFVhgo < String > { GNchTXIpHr . GRFIrbPhOM () . iter () . flat_map (| (_ , tlnCKjgPmg) | { tlnCKjgPmg . VCeqAEcxUW . iter () . map (| XzOXYaGyEv | XzOXYaGyEv . splitn (2 , '.') . collect :: < Vec < _ > > ()) }) . filter_map (| tXkzEjyjCP | { if tXkzEjyjCP . len () == 2 { Some (tXkzEjyjCP [1] . to_owned ()) } else { None } }) . collect () } async fn nApXytTlCs < 'a > (lCUpIZPfFj : & IGGqPVcktO , tDeTGfMeia : & ezcSaHgATl , xellGGmrWB : & 'a hVTcIFVhgo < String > , WWDJWxKhST : & LcqOtrfUKI ,) -> Option < & 'a str > { for SRytBffxDz in xellGGmrWB { let OcBoDZYOcL = tDeTGfMeia . lookup_ip (SRytBffxDz) . await ; let PFyczyICWc = OcBoDZYOcL . map (| UUNdyUntoM | { UUNdyUntoM . iter () . filter_map (| QwsqLsWwrd | OXdmvYQuUy (* WWDJWxKhST , QwsqLsWwrd) . ok ()) . filter (| LVDkErDHue | LVDkErDHue == & lCUpIZPfFj . ehmAIyyTsT) . next () }) . ok () . flatten () ; if PFyczyICWc . is_some () { return Some (SRytBffxDz . as_str ()) ; } } None } async fn ZVmEZkuOlw (TUFCUEtrUx : & IGGqPVcktO , lrhvgiNwYI : & str , GVofmsLViF : LcqOtrfUKI , gaqbSJgxXt : & mut SAuuizgQav ,) -> anyhow :: Result < () > { if let Some (eIAEUscbdU) = & TUFCUEtrUx . RCEWxSXxDu { let mut UKOPexzmOw = TUFCUEtrUx . clone () ; UKOPexzmOw . aAoAoHiCrb . insert (format ! ("Domain controller for {}" , lrhvgiNwYI)) ; gaqbSJgxXt . HnkMAlBSbZ (& UKOPexzmOw) ; let mHhDOeTgkY = gaqbSJgxXt . DpuPGGptIC () ; let mut iaFMOAbNZT = tokio :: time :: timeout (mHhDOeTgkY , SgpKuYTOEh :: ZqFbFZzmBO (UKOPexzmOw . ehmAIyyTsT , lrhvgiNwYI , & UKOPexzmOw . EUIBybvxzR , eIAEUscbdU ,) ,) . await . context ("ldap connection timed out") ? . context ("error connecting to ldap") ? ; let mut yvBGDVynzf = ResolverConfig :: new () ; yvBGDVynzf . add_name_server (NameServerConfig :: new ((UKOPexzmOw . ehmAIyyTsT , 53) . into () , Protocol :: Tcp ,)) ; yvBGDVynzf . set_domain (format ! ("{}." , lrhvgiNwYI) . parse () . context ("domain has invalid format for DNS resolver") ? ,) ; let mut OyCsLeflAU = ResolverOpts :: default () ; OyCsLeflAU . timeout = mHhDOeTgkY ; OyCsLeflAU . attempts = 2 ; let iNXbbDQMuN = ezcSaHgATl :: tokio (yvBGDVynzf , OyCsLeflAU) ; for plkMIYWVCf in iaFMOAbNZT . mrYxCAWUem () . await ? { let PoxeTfHoFK = iNXbbDQMuN . lookup_ip (plkMIYWVCf . vMoYcEINHf . clone ()) . await . ok () . and_then (| FYRQoXZymU | FYRQoXZymU . iter () . next ()) . and_then (| LLHXzlSvKk | { log :: info ! ("Computer {} has ip {}" , plkMIYWVCf . YoMZFBEXti , LLHXzlSvKk) ; OXdmvYQuUy (GVofmsLViF , LLHXzlSvKk) . ok () }) . and_then (| NjwAxvJLsz | gaqbSJgxXt . gDMPzCpkmL (NjwAxvJLsz)) ; match PoxeTfHoFK { Some (fOkuNhzWKe) => { let mut JSGrptPDwf = fOkuNhzWKe . clone () ; JSGrptPDwf . VCeqAEcxUW . insert (plkMIYWVCf . YoMZFBEXti) ; JSGrptPDwf . VCeqAEcxUW . insert (plkMIYWVCf . vMoYcEINHf) ; if let Some (EqpGhusqXt) = plkMIYWVCf . RkTmGzJZwW { log :: info ! ("Host {} has OS {}" , JSGrptPDwf , EqpGhusqXt) ; if EqpGhusqXt . to_lowercase () . contains ("windows") { JSGrptPDwf . WpFxLZmBnAjyBPT = ZmBnAjyBPT :: Windows ; JSGrptPDwf . EUIBybvxzR = gaqbSJgxXt . VRWcNuqsev () . into () ; } else if EqpGhusqXt . to_lowercase () . contains ("linux") { JSGrptPDwf . WpFxLZmBnAjyBPT = ZmBnAjyBPT :: UnixLike ; JSGrptPDwf . EUIBybvxzR = gaqbSJgxXt . dfluOhyNbg () . into () ; } JSGrptPDwf . aAoAoHiCrb . insert (format ! ("{} {}" , EqpGhusqXt , plkMIYWVCf . vShGbXshZt . unwrap_or ("" . into ())) . trim () . to_string () ,) ; } gaqbSJgxXt . HnkMAlBSbZ (& JSGrptPDwf) ; } None => log :: warn ! ("No host found for hostname {} in domain" , plkMIYWVCf . YoMZFBEXti) , } } Ok (()) } else { anyhow :: bail ! ("Detected domain for DC {}, but no password!" , TUFCUEtrUx . ehmAIyyTsT) ; } } pub async fn uAfuAyQMFM (Ynjqxsriwd : & mut SAuuizgQav) -> anyhow :: Result < () > { let mapKZbYbqL = Ynjqxsriwd . sElCDVdLmF () . context ("no cidr set; have you run a scan?") ? ; let PxwagZDSwR = ypjgWDuvYs (Ynjqxsriwd) ; log :: info ! ("Found domains {:?}" , PxwagZDSwR) ; let LtWknvvBph : Vec < _ > = Ynjqxsriwd . GRFIrbPhOM () . iter () . filter (| (_ , AWxGHTKhpR) | AWxGHTKhpR . AtxPWiUcZC . contains (& 53)) . map (| (_ , sEXgILeXxu) | { log :: debug ! ("Adding DNS server {}" , sEXgILeXxu) ; let mut jPqDsKBgtq = ResolverConfig :: new () ; jPqDsKBgtq . add_name_server (NameServerConfig :: new ((sEXgILeXxu . ehmAIyyTsT . clone () , 53) . into () , Protocol :: Tcp ,)) ; (sEXgILeXxu . clone () , ezcSaHgATl :: tokio (jPqDsKBgtq , Default :: default ()) ,) }) . collect () ; let XQCfbitbUX = Ynjqxsriwd . DpuPGGptIC () ; for (WpSVcgwnNm , MAhMqoIiax) in LtWknvvBph { match tokio :: time :: timeout (XQCfbitbUX , nApXytTlCs (& WpSVcgwnNm , & MAhMqoIiax , & PxwagZDSwR , & mapKZbYbqL) ,) . await { Ok (JBEpgSkrHc) => match JBEpgSkrHc { Some (DebzBiINAy) => { log :: info ! ("Found domain {} for host {}" , DebzBiINAy , WpSVcgwnNm) ; if let Err (eUorZUyKnK) = ZVmEZkuOlw (& WpSVcgwnNm , DebzBiINAy , mapKZbYbqL , Ynjqxsriwd) . await { log :: warn ! ("Error while running LDAP for DC {}: {}" , WpSVcgwnNm , eUorZUyKnK) ; } } None => log :: debug ! ("No domain matched for DNS server {}" , WpSVcgwnNm) , } , Err (_) => log :: debug ! ("DNS connection timed out for host {}" , WpSVcgwnNm) , } } Ok (()) } } mod JGeqoefCzA { use crate :: yTfuPFijth :: prlaGhOsIe :: dMuMOyFgHM ; use crate :: RwhTHuZJWW :: { muhnZaVSpE , LWLYjkqmGs , ZmBnAjyBPT } ; use crate :: XnwjfBIAxG :: zoZbZhvcJR :: ZXRMRESuzD as ezxlyekUUR ; use crate :: ZumChqTorR :: SAuuizgQav as wIHVcrelvN ; use cidr :: IpCidr as QCXkNrsNjZ ; use clap :: Args ; # [derive (Args)] pub struct ScanCommand { pub subnet : QCXkNrsNjZ , # [arg (short , long)] pub linux_root : Option < String > , # [arg (short , long)] pub windows_root : Option < String > , pub pass : String , # [arg (short , long , default_value_t = 22)] pub port : u16 , # [arg (short , long , default_value_t = LWLYjkqmGs :: RustScan)] pub backend : LWLYjkqmGs , } pub async fn OItdOMmWWV (yhAxXVivdV : ScanCommand , HznbPSouOE : & mut wIHVcrelvN ,) -> anyhow :: Result < () > { log :: debug ! ("Subnet: {:?}" , yhAxXVivdV . subnet) ; HznbPSouOE . CtFTwTYgKa (yhAxXVivdV . subnet) ; let IWLFWeRRlE = muhnZaVSpE :: szKGOIdLRv (& yhAxXVivdV . subnet , & muhnZaVSpE :: HueKzSAEQg () , yhAxXVivdV . backend , HznbPSouOE . DpuPGGptIC () ,) . await ? ; let nJxSMqUFtR = yhAxXVivdV . linux_root . unwrap_or (HznbPSouOE . dfluOhyNbg () . into ()) ; let mjRqZJasFs = yhAxXVivdV . windows_root . unwrap_or (HznbPSouOE . VRWcNuqsev () . into ()) ; for GroDaOHNkG in IWLFWeRRlE . vuUyZghFip { let RhOFtcGnOH = match GroDaOHNkG . dciExZZqwj { ZmBnAjyBPT :: UnixLike => & nJxSMqUFtR , ZmBnAjyBPT :: Windows => & mjRqZJasFs , } . clone () ; log :: info ! ("Found host {} with os {:?}, ports: {}" , GroDaOHNkG . TLxIayDIUv , GroDaOHNkG . dciExZZqwj , ezxlyekUUR (& GroDaOHNkG . EsDudBsHYo)) ; HznbPSouOE . dwUCdvcSIO (& GroDaOHNkG , RhOFtcGnOH , Some (yhAxXVivdV . pass . clone ()) , yhAxXVivdV . port ,) ? ; } Ok (()) } # [derive (Args)] pub struct RescanCommand { pub host : String , pub ports : Option < Vec < u16 > > , # [arg (short , long , default_value_t = LWLYjkqmGs :: RustScan)] pub backend : LWLYjkqmGs , } pub async fn dXilcTbWCk (CJdETqbEMr : RescanCommand , TlmeXEtzDM : & mut wIHVcrelvN ,) -> anyhow :: Result < () > { let mut fkDBfhISqC = dMuMOyFgHM (TlmeXEtzDM , & CJdETqbEMr . host) ? . clone () ; let mut ewmMYwSeHi = muhnZaVSpE :: HueKzSAEQg () ; ewmMYwSeHi . extend (CJdETqbEMr . ports . unwrap_or (Vec :: new ())) ; log :: debug ! ("Rescanning for host {}" , fkDBfhISqC) ; let yybFzXsEeY = muhnZaVSpE :: szKGOIdLRv (& QCXkNrsNjZ :: new_host (fkDBfhISqC . ehmAIyyTsT) , & ewmMYwSeHi , CJdETqbEMr . backend , TlmeXEtzDM . DpuPGGptIC () ,) . await ? ; if yybFzXsEeY . vuUyZghFip . len () == 0 { anyhow :: bail ! ("No hosts scanned; is the host up?") ; } let BmFvJQaHNF = & yybFzXsEeY . vuUyZghFip [0] ; log :: info ! ("Got ports {}" , ezxlyekUUR (& BmFvJQaHNF . EsDudBsHYo)) ; fkDBfhISqC . AtxPWiUcZC = BmFvJQaHNF . EsDudBsHYo . clone () ; TlmeXEtzDM . HnkMAlBSbZ (& fkDBfhISqC) ; Ok (()) } # [derive (Args)] pub struct PortCheckCommand { pub host : String , # [arg (required = true)] pub ports : Vec < u16 > , # [arg (short , long , default_value_t = LWLYjkqmGs :: RustScan)] pub backend : LWLYjkqmGs , } pub async fn jOGtEZVMnI (gsOHscoRwV : PortCheckCommand , aNdHIWsHOD : & mut wIHVcrelvN ,) -> anyhow :: Result < () > { let uZAwvXBvfT = dMuMOyFgHM (aNdHIWsHOD , & gsOHscoRwV . host) ? ; let AcsAhfNoEv = muhnZaVSpE :: szKGOIdLRv (& QCXkNrsNjZ :: new_host (uZAwvXBvfT . ehmAIyyTsT) , & gsOHscoRwV . ports , gsOHscoRwV . backend , aNdHIWsHOD . DpuPGGptIC () ,) . await ? ; if AcsAhfNoEv . vuUyZghFip . len () == 0 { anyhow :: bail ! ("No hosts scanned; is the host up?") ; } let TziKwOjepU = & AcsAhfNoEv . vuUyZghFip [0] ; let (HbtbQnkxeX , KXjPttaXNP) : (Vec < u16 > , _) = gsOHscoRwV . ports . iter () . partition (| KZtaOfMYho | TziKwOjepU . EsDudBsHYo . contains (KZtaOfMYho)) ; log :: info ! ("Open   ports: {}" , ezxlyekUUR (HbtbQnkxeX)) ; log :: info ! ("Closed ports: {}" , ezxlyekUUR (KXjPttaXNP)) ; Ok (()) } } pub mod OkfEqSwBbQ { use crate :: swLTSvogNs :: mGPrLlRuJE :: yiqafanmjb ; use crate :: yTfuPFijth :: prlaGhOsIe :: dMuMOyFgHM ; use crate :: ZumChqTorR :: { IGGqPVcktO , SAuuizgQav } ; use anyhow :: Context ; use clap :: Args ; use std :: path :: { Path , PathBuf } ; use std :: time :: Duration ; use tokio :: task :: JoinSet ; # [derive (Clone)] pub struct bshZjBMFZq { KLVNsCQiHT : PathBuf , waFAmnFmFd : Vec < String > , lqpnvPSHtn : bool , } impl bshZjBMFZq { pub fn MaCAQiXDYv (EcaTbNsxJp : PathBuf) -> Self { Self { KLVNsCQiHT : EcaTbNsxJp , waFAmnFmFd : Vec :: new () , lqpnvPSHtn : false , } } pub fn BdbQxFldDb (mut self , ELgWCKghUe : bool) -> Self { self . lqpnvPSHtn = ELgWCKghUe ; self } pub fn OySGCOLiUU (mut self , rBFyweWStE : Vec < String >) -> Self { self . waFAmnFmFd = rBFyweWStE ; self } } async fn qXnXcxSZvG (YwsSryeMWJ : & IGGqPVcktO , wTvadeynSy : bshZjBMFZq ,) -> anyhow :: Result < (u32 , String) > { if let Some (XMWQZXxvZe) = & YwsSryeMWJ . RCEWxSXxDu { let mut PVwkKwHbPr = yiqafanmjb :: SzAhzDkJOY (& YwsSryeMWJ . EUIBybvxzR , XMWQZXxvZe , (YwsSryeMWJ . ehmAIyyTsT , YwsSryeMWJ . XfiOfpdLRW) ,) . await ? ; let (TXbZhuaFLZ , wDhAWzFlgn) = PVwkKwHbPr . PyObXhiFqw (& wTvadeynSy . KLVNsCQiHT , wTvadeynSy . waFAmnFmFd , true , wTvadeynSy . lqpnvPSHtn ,) . await ? ; let XrnxLHJFTg = String :: from_utf8_lossy (& wDhAWzFlgn) ; Ok ((TXbZhuaFLZ , XrnxLHJFTg . into ())) } else { anyhow :: bail ! ("No password for host set") } } pub async fn JJDTCeQIWx (GZCbGAfwZA : Duration , LugnQxAHtG : & IGGqPVcktO , FIKRJNdJsi : bshZjBMFZq ,) -> anyhow :: Result < (u32 , String) > { tokio :: time :: timeout (GZCbGAfwZA , qXnXcxSZvG (LugnQxAHtG , FIKRJNdJsi)) . await . unwrap_or_else (| _ | Err (anyhow :: Error :: msg ("run_script_args timed out"))) } pub async fn lOJGAykXCv (mfrlZivTtq : Duration , otYpELrHTf : & IGGqPVcktO , hNgRpHcxVa : bshZjBMFZq ,) -> anyhow :: Result < (u32 , String) > { JJDTCeQIWx (mfrlZivTtq , otYpELrHTf , hNgRpHcxVa) . await } pub async fn xHzUUUXpEA < F : FnMut (& IGGqPVcktO) -> Vec < String > > (eXgTkeIGaL : Duration , EaMPfyPnUb : & SAuuizgQav , mut vEwxMVYGsq : F , uPScpWGIXl : bshZjBMFZq ,) -> JoinSet < (IGGqPVcktO , anyhow :: Result < (u32 , String) >) > { log :: info ! ("Executing script on all hosts") ; let mut vfkeozcQGH = JoinSet :: new () ; for (_ , wSAxnPmpqQ) in EaMPfyPnUb . HfWyDHbgoo () { let tLcAvbQJUK = wSAxnPmpqQ . clone () ; let mut GWpoutzbGv = uPScpWGIXl . clone () ; GWpoutzbGv . waFAmnFmFd = vEwxMVYGsq (& tLcAvbQJUK) ; vfkeozcQGH . spawn (async move { (tLcAvbQJUK . clone () , JJDTCeQIWx (eXgTkeIGaL , & tLcAvbQJUK , GWpoutzbGv . clone ()) . await ,) }) ; } vfkeozcQGH } pub async fn nLKRHGCIYY (VyCtwqBepo : Duration , RZxjMqBgsC : & SAuuizgQav , PefjdvsUpu : bshZjBMFZq ,) -> JoinSet < (IGGqPVcktO , anyhow :: Result < (u32 , String) >) > { let FoWUUSVkbW = PefjdvsUpu . waFAmnFmFd . clone () ; xHzUUUXpEA (VyCtwqBepo , RZxjMqBgsC , | _ | FoWUUSVkbW . clone () , PefjdvsUpu) . await } async fn YqSXgFtsyQ (aStSjFrxkZ : & IGGqPVcktO , sYfJBOkTDv : & Path) -> anyhow :: Result < () > { if let Some (HFEtywKAhT) = & aStSjFrxkZ . RCEWxSXxDu { let mut SNVQwyRMou = yiqafanmjb :: SzAhzDkJOY (& aStSjFrxkZ . EUIBybvxzR , HFEtywKAhT , (aStSjFrxkZ . ehmAIyyTsT , aStSjFrxkZ . XfiOfpdLRW) ,) . await ? ; SNVQwyRMou . MpDZOTLLcB (sYfJBOkTDv) . await ? ; Ok (()) } else { anyhow :: bail ! ("No password for host set") } } async fn GKiPEGaUzu (ioyoGNKUHz : Duration , lYotsiOnUW : & IGGqPVcktO , pLGWxytuqH : & Path ,) -> anyhow :: Result < () > { tokio :: time :: timeout (ioyoGNKUHz , YqSXgFtsyQ (lYotsiOnUW , pLGWxytuqH)) . await . unwrap_or_else (| _ | Err (anyhow :: Error :: msg ("run_script_args timed out"))) } pub async fn PspoJTFfOR (OkSedDJAeH : Duration , cwPnonEsGI : & SAuuizgQav , yyTOeScTaX : & Path ,) -> JoinSet < (IGGqPVcktO , anyhow :: Result < () >) > { let mut UvxxopWcPt = JoinSet :: new () ; for (_ , aRBCPUmhht) in cwPnonEsGI . HfWyDHbgoo () { let ygydcMkuQQ = aRBCPUmhht . clone () ; let GUhOcMxcTz = yyTOeScTaX . to_owned () ; UvxxopWcPt . spawn (async move { (ygydcMkuQQ . clone () , GKiPEGaUzu (OkSedDJAeH , & ygydcMkuQQ , & GUhOcMxcTz) . await ,) }) ; } UvxxopWcPt } # [derive (Args)] pub struct ScriptCommand { pub script : PathBuf , # [arg (short ('H') , long)] pub host : Option < String > , # [arg (short , long , default_value_t = false)] pub upload : bool , pub args : Vec < String > , } pub async fn HXyBXfzzHg (ugyXKvdOoq : ScriptCommand , wOhwJJRlIP : & mut SAuuizgQav ,) -> anyhow :: Result < () > { match ugyXKvdOoq . host { Some (NftpaFjIUi) => { let DoEDYsjVYb = dMuMOyFgHM (& wOhwJJRlIP , & NftpaFjIUi) ? ; log :: info ! ("Running script on host {}" , DoEDYsjVYb) ; let (LrcWTKbYNf , YouWSHnkHM) = lOJGAykXCv (wOhwJJRlIP . BHfMBVoJEQ () , DoEDYsjVYb , bshZjBMFZq :: MaCAQiXDYv (ugyXKvdOoq . script) . BdbQxFldDb (ugyXKvdOoq . upload) ,) . await ? ; log :: info ! ("Script exited with code {}. Output: {}" , LrcWTKbYNf , YouWSHnkHM) ; } None => { let mut oSMtfESmVX = nLKRHGCIYY (wOhwJJRlIP . BHfMBVoJEQ () , wOhwJJRlIP , bshZjBMFZq :: MaCAQiXDYv (ugyXKvdOoq . script) . BdbQxFldDb (ugyXKvdOoq . upload) . OySGCOLiUU (ugyXKvdOoq . args) ,) . await ; while let Some (SpOMPSSUiH) = oSMtfESmVX . join_next () . await { SpOMPSSUiH . context ("Error running script") . map (| (anvtevyOty , jcunRsOUky) | match jcunRsOUky { Ok ((KmpYDeqGYl , kEZgpqOYlF)) => { log :: info ! ("Script on host {} returned code {} with output: {}" , anvtevyOty , KmpYDeqGYl , kEZgpqOYlF) ; } Err (YYRUHCpBAU) => { log :: error ! ("Error running script on host {}: {}" , anvtevyOty , YYRUHCpBAU) ; } } ,) ? ; } } } Ok (()) } # [derive (Args)] pub struct ShellCommand { pub host : String , } pub async fn mUtJRRwTXl (HYTPQpJHyQ : ShellCommand , QcIiJwMDYN : & mut SAuuizgQav ,) -> anyhow :: Result < () > { let BbEYAnMuWe = dMuMOyFgHM (QcIiJwMDYN , & HYTPQpJHyQ . host) ? ; if let Some (tfhEQMbVSa) = & BbEYAnMuWe . RCEWxSXxDu { let mut NvjtdvRpZx = yiqafanmjb :: SzAhzDkJOY (& BbEYAnMuWe . EUIBybvxzR , & tfhEQMbVSa , (BbEYAnMuWe . ehmAIyyTsT , BbEYAnMuWe . XfiOfpdLRW) ,) . await ? ; log :: info ! ("ssh {}@{} -p {}" , BbEYAnMuWe . EUIBybvxzR , BbEYAnMuWe , BbEYAnMuWe . XfiOfpdLRW) ; log :: info ! ("Using password '{}'" , & tfhEQMbVSa) ; let pbVmSzeZHH = NvjtdvRpZx . TgSSLzpblV () . await ? ; if pbVmSzeZHH != 0 { log :: warn ! ("Shell returned nonzero code {}" , pbVmSzeZHH) ; } } else { log :: error ! ("Host does not have a password set! Please set it first.") ; } Ok (()) } # [derive (Args)] pub struct UploadCommand { pub file : PathBuf , pub host : Option < String > , } pub async fn GqXtopYwYh (jBhPRscBPt : UploadCommand , kBgGuzyaab : & mut SAuuizgQav ,) -> anyhow :: Result < () > { let ESrNzHpjQm = kBgGuzyaab . BHfMBVoJEQ () ; match jBhPRscBPt . host { Some (mzkaGPnADY) => { let ejMCzVdGUx = dMuMOyFgHM (kBgGuzyaab , & mzkaGPnADY) ? ; GKiPEGaUzu (ESrNzHpjQm , ejMCzVdGUx , & jBhPRscBPt . file) . await } None => { let mut TtzXIbijqd = PspoJTFfOR (ESrNzHpjQm , kBgGuzyaab , & jBhPRscBPt . file) . await ; while let Some (ARabYEOOMn) = TtzXIbijqd . join_next () . await { let (QOFJIqnkMk , LupCExHvYK) = ARabYEOOMn . context ("Failed to run upload command") ? ; match LupCExHvYK { Ok (()) => { log :: info ! ("Successfully uploaded script to host {}" , QOFJIqnkMk) ; } Err (WlWaulZaWb) => { log :: error ! ("Failed to upload script on host {}: {}" , QOFJIqnkMk , WlWaulZaWb) ; } } } Ok (()) } } } async fn vRncYFMMan (yiWsvncdMP : & mut SAuuizgQav , NlrQEGHHRn : & str , wZPmsbrWCf : Vec < String > ,) -> anyhow :: Result < () > { HXyBXfzzHg (ScriptCommand { script : PathBuf :: from (format ! ("{}.sh" , NlrQEGHHRn)) , host : None , upload : false , args : wZPmsbrWCf , } , yiWsvncdMP ,) . await } async fn XemAlWCFkh (ncUuwVrpMC : & mut SAuuizgQav , gAxyrJHpIf : & str) -> anyhow :: Result < () > { vRncYFMMan (ncUuwVrpMC , gAxyrJHpIf , vec ! []) . await } pub async fn cnePEnxSFe (aUbpxoWzku : () , daAAzkFBqm : & mut SAuuizgQav) -> anyhow :: Result < () > { log :: info ! ("Running hardening scripts") ; XemAlWCFkh (daAAzkFBqm , "php") . await ? ; XemAlWCFkh (daAAzkFBqm , "ssh") . await ? ; XemAlWCFkh (daAAzkFBqm , "lockdown") . await ? ; GqXtopYwYh (UploadCommand { file : PathBuf :: from ("firewall_template.sh") , host : None , } , daAAzkFBqm ,) . await ? ; vRncYFMMan (daAAzkFBqm , "initial_backup" , vec ! ["/etc/backup" . into ()]) . await ? ; XemAlWCFkh (daAAzkFBqm , "ident") . await ? ; Ok (()) } } # [derive (Parser)] pub enum AYVjydJzVs { Scan (JGeqoefCzA :: ScanCommand) , Rescan (JGeqoefCzA :: RescanCommand) , # [clap (alias = "pc")] PortCheck (JGeqoefCzA :: PortCheckCommand) , # [clap (alias = "a")] Add (prlaGhOsIe :: AddCommand) , # [clap (alias = "rm")] Remove (prlaGhOsIe :: RemoveCommand) , # [clap (alias = "ls")] List (prlaGhOsIe :: ListCommand) , # [clap (alias = "i")] Info (prlaGhOsIe :: InfoCommand) , # [clap (alias = "tm")] Timeout (prlaGhOsIe :: TimeoutCommand) , Export (prlaGhOsIe :: ExportCommand) , Import (prlaGhOsIe :: ImportCommand) , # [clap (alias = "e")] Edit (prlaGhOsIe :: EditCommand) , Exclude (prlaGhOsIe :: ExcludeCommand) , # [clap (alias = "r")] Chpass , # [clap (alias = "sc")] Script (OkfEqSwBbQ :: ScriptCommand) , Base , # [clap (alias = "sh")] Shell (OkfEqSwBbQ :: ShellCommand) , # [clap (alias = "up")] Upload (OkfEqSwBbQ :: UploadCommand) , # [clap (alias = "pr")] Profile (UoXbFBgQay :: ProfileCommand) , Ldap (LvoiAvJSBy :: LdapCommand) , } pub async fn prkPEdaRee (CdzHbkJMar : AYVjydJzVs , YuNNENOlnq : & mut SAuuizgQav ,) -> anyhow :: Result < () > { match CdzHbkJMar { AYVjydJzVs :: Scan (STiGhLbruT) => JGeqoefCzA :: OItdOMmWWV (STiGhLbruT , YuNNENOlnq) . await ? , AYVjydJzVs :: Rescan (xwscQyPkfy) => { JGeqoefCzA :: dXilcTbWCk (xwscQyPkfy , YuNNENOlnq) . await ? } AYVjydJzVs :: PortCheck (ranmdCpaaC) => { JGeqoefCzA :: jOGtEZVMnI (ranmdCpaaC , YuNNENOlnq) . await ? } AYVjydJzVs :: Add (gWdTLJUDUX) => prlaGhOsIe :: XsdkkHPidi (gWdTLJUDUX , YuNNENOlnq) . await ? , AYVjydJzVs :: Remove (xdbvsNFAvD) => { prlaGhOsIe :: rlmyMMQjGO (xdbvsNFAvD , YuNNENOlnq) . await ? } AYVjydJzVs :: List (vNCoiQhXhp) => prlaGhOsIe :: vkMacxgkoZ (vNCoiQhXhp , YuNNENOlnq) . await ? , AYVjydJzVs :: Info (qcFtTddBJZ) => prlaGhOsIe :: uKVYdOeOkX (qcFtTddBJZ , YuNNENOlnq) . await ? , AYVjydJzVs :: Timeout (AxrnQtpLuq) => { prlaGhOsIe :: BMsGldHZJH (AxrnQtpLuq , YuNNENOlnq) . await ? } AYVjydJzVs :: Export (sQqHGEqNak) => { prlaGhOsIe :: EUvRweneUS (sQqHGEqNak , YuNNENOlnq) . await ? } AYVjydJzVs :: Import (AMGtoLJLFz) => { prlaGhOsIe :: AckqVUCmOe (AMGtoLJLFz , YuNNENOlnq) . await ? } AYVjydJzVs :: Exclude (GQbXAdTKmn) => { prlaGhOsIe :: VXnPdYKOMT (GQbXAdTKmn , YuNNENOlnq) . await ? } AYVjydJzVs :: Chpass => cnvYOFcqad :: SctIChbTQu (() , YuNNENOlnq) . await ? , AYVjydJzVs :: Script (vPprHejCyD) => { OkfEqSwBbQ :: HXyBXfzzHg (vPprHejCyD , YuNNENOlnq) . await ? } AYVjydJzVs :: Base => OkfEqSwBbQ :: cnePEnxSFe (() , YuNNENOlnq) . await ? , AYVjydJzVs :: Shell (MSyIjvacih) => OkfEqSwBbQ :: mUtJRRwTXl (MSyIjvacih , YuNNENOlnq) . await ? , AYVjydJzVs :: Upload (HPTNQfbpBx) => { OkfEqSwBbQ :: GqXtopYwYh (HPTNQfbpBx , YuNNENOlnq) . await ? } AYVjydJzVs :: Edit (spRnSunlJJ) => prlaGhOsIe :: aAkucCRoyG (spRnSunlJJ , YuNNENOlnq) . await ? , AYVjydJzVs :: Profile (DrfKptZbuq) => { UoXbFBgQay :: XAzfUKbpUB (DrfKptZbuq , YuNNENOlnq) . await ? } AYVjydJzVs :: Ldap (RigbvgmJAz) => LvoiAvJSBy :: TupzFuCqIz (RigbvgmJAz , YuNNENOlnq) . await ? , } Ok (()) } } mod RwhTHuZJWW { use crate :: XnwjfBIAxG :: zoZbZhvcJR :: PjHkMurZeo ; use anyhow :: Context ; use cidr :: IpCidr as DmBvnkKrgC ; use clap :: ValueEnum ; use nmap_xml_parser :: { host :: { Address , Host as sSyKnRiYHf } , NmapResults , } ; use rustscan :: input :: ScanOrder as ZMlePtTbsP ; use rustscan :: port_strategy :: PortStrategy as mJKxHEXdvo ; use rustscan :: scanner :: Scanner as txTwVUoVdl ; use serde :: { Deserialize , Serialize } ; use std :: { collections :: { HashMap as yNSnqqaRKD , HashSet } , fmt :: { Display , Formatter } , net :: IpAddr as LkRZFMCrmB , process :: Stdio , time :: Duration , } ; use tokio :: { fs :: read_to_string , process :: Command } ; # [derive (Clone , Debug)] pub struct muhnZaVSpE { pub vuUyZghFip : Vec < JSBnVRVdkm > , } # [derive (Serialize , Deserialize , Clone , Copy , Debug , ValueEnum , PartialEq , Eq)] pub enum ZmBnAjyBPT { # [value (alias ("unix"))] UnixLike , # [value (alias ("win"))] Windows , } # [derive (Clone , Debug)] pub struct JSBnVRVdkm { pub TLxIayDIUv : LkRZFMCrmB , pub EsDudBsHYo : HashSet < u16 > , pub dciExZZqwj : ZmBnAjyBPT , } impl JSBnVRVdkm { pub fn onrEHZFidu (HqVIKLUMao : LkRZFMCrmB , ZpzwJfJoFA : HashSet < u16 >) -> JSBnVRVdkm { let WTiZMvwMXY = if ZpzwJfJoFA . iter () . any (| lRGXrEwibb | lRGXrEwibb == & 3389) { ZmBnAjyBPT :: Windows } else { ZmBnAjyBPT :: UnixLike } ; JSBnVRVdkm { TLxIayDIUv : HqVIKLUMao , EsDudBsHYo : ZpzwJfJoFA , dciExZZqwj : WTiZMvwMXY , } } } impl TryFrom < & sSyKnRiYHf > for JSBnVRVdkm { type Error = anyhow :: Error ; fn try_from (CyZpxHlJPT : & sSyKnRiYHf) -> anyhow :: Result < Self > { let AmCNryevTj = CyZpxHlJPT . addresses () . filter_map (| QSyEwHDhMV | match QSyEwHDhMV { Address :: IpAddr (zCuzYaLQGG) => Some (zCuzYaLQGG) , _ => None , }) . next () . ok_or_else (| | anyhow :: Error :: msg ("no IP addresses for nmap host")) ? ; let RNtvcsxxJn : HashSet < u16 > = CyZpxHlJPT . port_info . ports () . map (| MfMHFRVwFe | MfMHFRVwFe . port_number) . collect () ; Ok (JSBnVRVdkm :: onrEHZFidu (AmCNryevTj . clone () , RNtvcsxxJn)) } } # [derive (Clone , Debug , ValueEnum)] pub enum LWLYjkqmGs { Nmap , RustScan , } impl Display for LWLYjkqmGs { fn fmt (& self , vqYZBNADJW : & mut Formatter < '_ >) -> std :: fmt :: Result { let siOXUdowNt = match self { LWLYjkqmGs :: Nmap => "nmap" , LWLYjkqmGs :: RustScan => "rust-scan" , } ; vqYZBNADJW . write_str (siOXUdowNt) } } impl muhnZaVSpE { async fn qFAjgGKwhC (KOtmAISivj : & DmBvnkKrgC , vdywDLsWjW : & Vec < u16 > ,) -> anyhow :: Result < Vec < JSBnVRVdkm > > { let ovwkHdyMoi = PjHkMurZeo (vdywDLsWjW , ",") ; let fHPpSCsKvk = vec ! ["--min-rate" , "3000" , "-p" , & ovwkHdyMoi , "--open" , "-oX" , "scan.xml" , KOtmAISivj . to_string () . leak () ,] ; let RYizTSmhmw = Command :: new ("nmap") . args (fHPpSCsKvk) . stdout (Stdio :: null ()) . status () . await . context ("nmap failed to spawn") ? . success () ; if RYizTSmhmw == false { anyhow :: bail ! ("nmap failed to execute") ; } let YESsppUQUH = read_to_string ("scan.xml") . await . context ("nmap output file not readable") ? ; let rzkqjQuGWb = NmapResults :: parse (& YESsppUQUH) . context ("nmap output file not parseable") ? ; Ok (rzkqjQuGWb . hosts () . filter_map (| bAxouvyXfX | bAxouvyXfX . try_into () . ok ()) . collect ()) } async fn rgKeWYJYZP (JFopwwZlJp : & DmBvnkKrgC , XcgfhLlSEH : & Vec < u16 > , NrJbnZamBA : Duration ,) -> anyhow :: Result < Vec < JSBnVRVdkm > > { let mPADoOoKaj : Vec < LkRZFMCrmB > = JFopwwZlJp . iter () . map (| tkWGyObOSy | tkWGyObOSy . address ()) . collect () ; let cdSLzavwdC = mJKxHEXdvo :: pick (& None , Some (XcgfhLlSEH . clone ()) , ZMlePtTbsP :: Serial) ; let vBatVxUkBN = txTwVUoVdl :: new (& mPADoOoKaj , 100 , NrJbnZamBA , 1 , true , cdSLzavwdC , true , vec ! [] , false ,) ; log :: info ! ("rustscan -a {} -g -t {} -p {}" , JFopwwZlJp , NrJbnZamBA . as_millis () , PjHkMurZeo (XcgfhLlSEH , ",")) ; let mut BZoUwuNdgZ = yNSnqqaRKD :: < LkRZFMCrmB , HashSet < u16 > > :: new () ; vBatVxUkBN . run () . await . iter () . for_each (| drUsqrMgKq | { let vdnsplCIng = drUsqrMgKq . ip () ; BZoUwuNdgZ . entry (vdnsplCIng) . or_insert (HashSet :: new ()) . insert (drUsqrMgKq . port ()) ; }) ; Ok (BZoUwuNdgZ . into_iter () . map (| (hiJMknJTUD , ctoWPdlSBu) | JSBnVRVdkm :: onrEHZFidu (hiJMknJTUD , ctoWPdlSBu)) . collect ()) } pub fn HueKzSAEQg () -> Vec < u16 > { vec ! [22 , 3389 , 88 , 135 , 389 , 445 , 5985 , 3306 , 5432 , 27017 , 53 , 80 , 443 , 8080 ,] } pub async fn szKGOIdLRv (VOLkQYVHNN : & DmBvnkKrgC , pzpmbDHubf : & Vec < u16 > , RAGYwbBOzk : LWLYjkqmGs , gmnteoFUVE : Duration ,) -> anyhow :: Result < muhnZaVSpE > { Ok (muhnZaVSpE { vuUyZghFip : match RAGYwbBOzk { LWLYjkqmGs :: Nmap => muhnZaVSpE :: qFAjgGKwhC (VOLkQYVHNN , pzpmbDHubf) . await ? , LWLYjkqmGs :: RustScan => { muhnZaVSpE :: rgKeWYJYZP (VOLkQYVHNN , pzpmbDHubf , gmnteoFUVE) . await ? } } , }) } } } mod SaORjcyRVh { use anyhow :: Context as BxWlMkAfsJ ; use rust_embed :: Embed ; use std :: io :: Cursor as VcGvDaLIsm ; use std :: path :: { Path , PathBuf as DzHrEaJzDO } ; use tokio :: fs :: File as TyepkRzRvS ; use tokio :: io ; # [derive (Embed)] # [folder = "scripts/"] pub struct NWTiOLQiSb ; impl NWTiOLQiSb { pub fn dKpZVtqtoo () -> DzHrEaJzDO { "scripts/" . into () } async fn lXRPSeKwFP (XQzpZDnfIu : & Path) -> anyhow :: Result < bool > { let iAfusiPBgE = tokio :: fs :: create_dir (XQzpZDnfIu) . await ; if let Err (ENUOBXaOkm) = iAfusiPBgE { if ENUOBXaOkm . kind () == io :: ErrorKind :: AlreadyExists { log :: info ! ("Directory already exists, skipping unpack step") ; Ok (true) } else { Err (ENUOBXaOkm . into ()) } } else { Ok (false) } } async fn ookptDlPRX (lnDzwyKgDn : & str) -> anyhow :: Result < () > { let iShRQUCMJk = Self :: get (lnDzwyKgDn) . with_context (| | format ! ("failed to open file {}" , lnDzwyKgDn)) ? ; let mut LyjLXCNFBJ = Self :: dKpZVtqtoo () ; LyjLXCNFBJ . push (lnDzwyKgDn) ; let mut VvaZCGguQl = TyepkRzRvS :: create (LyjLXCNFBJ) . await ? ; let mut mBnezSJOex = VcGvDaLIsm :: new (iShRQUCMJk . data) ; io :: copy (& mut mBnezSJOex , & mut VvaZCGguQl) . await ? ; Ok (()) } pub async fn SOOUuxIaEX () -> anyhow :: Result < () > { let phdjmVBisI = Self :: dKpZVtqtoo () ; let kKAEnAwQFH = Self :: lXRPSeKwFP (& phdjmVBisI) . await ? ; if ! kKAEnAwQFH { for UQHUtmxaXr in Self :: iter () { if let Err (oxZmOEyHUD) = Self :: ookptDlPRX (& UQHUtmxaXr) . await { log :: warn ! ("Failed to copy file {}: {}" , UQHUtmxaXr , oxZmOEyHUD) ; } } } Ok (()) } pub async fn IiwSFwbMlv (CHSPSNQoIG : & Path) -> Option < TyepkRzRvS > { let mut AAioBBCQjh = Self :: dKpZVtqtoo () ; AAioBBCQjh . push (CHSPSNQoIG) ; TyepkRzRvS :: open (AAioBBCQjh) . await . ok () } } } mod XnwjfBIAxG { pub mod nygzfkJpcK { use cidr :: IpCidr as QNrfpiHvZc ; use std :: net :: IpAddr as HFVVOzPlWn ; pub fn CrchwJMsNc (AxQhZISWTP : QNrfpiHvZc , dGuzWFinbN : HFVVOzPlWn ,) -> anyhow :: Result < HFVVOzPlWn > { match AxQhZISWTP { QNrfpiHvZc :: V4 (jfzBkBskTG) => match dGuzWFinbN { HFVVOzPlWn :: V4 (nIKdyUrqdP) => { let RLiUPZNAql = jfzBkBskTG . mask () ; Ok (HFVVOzPlWn :: V4 (RLiUPZNAql & jfzBkBskTG . first_address () | (! RLiUPZNAql & nIKdyUrqdP) ,)) } HFVVOzPlWn :: V6 (_) => { anyhow :: bail ! ("Passed IPv4 CIDR and IPv6 IP") ; } } , QNrfpiHvZc :: V6 (ccAswusosw) => match dGuzWFinbN { HFVVOzPlWn :: V4 (_) => { anyhow :: bail ! ("Passed IPv6 CIDR and IPv4 IP") ; } HFVVOzPlWn :: V6 (EFsAoKYTov) => { let JhGtyBjLpq = ccAswusosw . mask () ; Ok (HFVVOzPlWn :: V6 ((JhGtyBjLpq & ccAswusosw . first_address ()) | (! JhGtyBjLpq & EFsAoKYTov) ,)) } } , } } } pub mod zoZbZhvcJR { pub fn PjHkMurZeo (RWpKLdGKqW : impl IntoIterator < Item = impl ToString > , MtMZDLDGDm : & str ,) -> String { RWpKLdGKqW . into_iter () . map (| BqHgVRyFog | BqHgVRyFog . to_string ()) . collect :: < Vec < _ > > () . join (MtMZDLDGDm) } pub fn ZXRMRESuzD (rwTAycabNY : impl IntoIterator < Item = impl ToString >) -> String { PjHkMurZeo (rwTAycabNY , ", ") } } } use clap :: Parser as LEXoZRSEaH ; use log :: LevelFilter as JufDHpspMC ; use std :: path :: PathBuf as AxByfYxHCa ; use yTfuPFijth :: { prkPEdaRee , AYVjydJzVs } ; use SaORjcyRVh :: NWTiOLQiSb as KXBedVcjyb ; use YtpbyjEmII :: fPDCOAZOqR as WjZVOxqRsa ; use ZumChqTorR :: SAuuizgQav as BnVzinadxz ; # [tokio :: main] async fn main () -> anyhow :: Result < () > { env_logger :: builder () . parse_default_env () . format_timestamp (None) . filter_module ("blaze" , JufDHpspMC :: Debug) . init () ; let mut jyltHgruQu = BnVzinadxz :: hLjrDRRznd (& AxByfYxHCa :: from ("blaze.yaml")) . unwrap_or_else (| EAtTZTjgnA | { log :: info ! ("Error loading config: {:?}, loading default" , EAtTZTjgnA) ; BnVzinadxz :: QJzJMmAYQK () }) ; KXBedVcjyb :: SOOUuxIaEX () . await . unwrap_or_else (| LWfJeWGBoh | { log :: warn ! ("Error unpacking scripts: {}, continuing" , LWfJeWGBoh) ; }) ; let rlfDTIZjFd = AYVjydJzVs :: try_parse () ; match rlfDTIZjFd { Err (_) => WjZVOxqRsa (& mut jyltHgruQu) . await ? , Ok (RoHzAREFQm) => prkPEdaRee (RoHzAREFQm , & mut jyltHgruQu) . await ? , } Ok (()) }